name: Rust Proxy Scanner for Workers (Ultimate/Final - Plaintext Var)

on:
  workflow_dispatch:
  schedule:
    - cron: '0 * * * *' # every hour

concurrency:
  group: rust-proxy-scan-final-plaintext
  cancel-in-progress: true

# Keep minimal permissions but include actions write because we delete runs later
permissions:
  contents: read
  actions: write

env:
  CARGO_TERM_COLOR: always
  CACHE_FILE: .cachelastbestip.txt
  RUST_CACHE_KEY: v4
  TIMEOUT_MINUTES: 30
  CF_ENVIRONMENT: production

jobs:
  update-proxy-variable:
    runs-on: ubuntu-latest
    timeout-minutes: ${{ env.TIMEOUT_MINUTES }}
    outputs:
      bestip: ${{ steps.scan.outputs.bestip }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup environment (jq, curl, netcat)
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq curl netcat-openbsd build-essential pkg-config libssl-dev

      - name: Restore Best IP Cache
        uses: actions/cache@v4
        id: ip-cache
        with:
          path: ${{ env.CACHE_FILE }}
          key: rust-proxy-scanner-best-ip-cache-${{ env.RUST_CACHE_KEY }}-${{ runner.os }}

      - name: Install Rust toolchain (stable)
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true

      - name: Cache Rust dependencies (target, registry)
        uses: actions/cache@v4
        with:
          path: |
            target
            ~/.cargo/registry
            ~/.cargo/git
          key: rust-cache-${{ env.RUST_CACHE_KEY }}-${{ runner.os }}

      - name: Build Rust project (release)
        run: |
          set -euo pipefail
          cargo build --release

      - name: Run scanner and choose best IP
        id: scan
        run: |
          set -euo pipefail
          BIN="./target/release/RScanner"

          if [ ! -x "$BIN" ]; then
            echo "‚ùå FATAL: Scanner executable not found at $BIN"
            ls -la ./target/release || true
            exit 1
          fi

          : > scan.log
          echo "üöÄ Starting proxy scan..."
          # run scanner; allow non-zero exit but capture output
          "$BIN" 2>&1 | tee -a scan.log || echo "‚ö†Ô∏è Scanner exited with non-zero code; parsing what we have."

          echo "üîç Parsing scan.log for live proxies and latencies..."
          awk '
            BEGIN{IGNORECASE=1}
            /PROXY[[:space:]]+LIVE/ {
              if (match($0, /([0-9]+)[[:space:]]*ms/, lat)) { latency=lat[1] } else next
              if (match($0, /([0-9]{1,3}(\.[0-9]{1,3}){3})/ , addr)) { ip=addr[1] } else next
              print latency, ip
            }
          ' scan.log | sort -n -k1,1 > candidates.txt || true

          BEST=""
          BEST_LAT=""

          if [ -s candidates.txt ]; then
            BEST_LAT=$(awk 'NR==1{print $1}' candidates.txt)
            BEST=$(awk 'NR==1{print $2}' candidates.txt)
            echo "‚úÖ Selected best candidate: $BEST (latency: ${BEST_LAT} ms)"
          else
            echo "üü° No live proxies parsed from scan.log. Will try cache fallback."
          fi

          # Fallback to cached IP
          if [ -z "${BEST:-}" ] && [ -f "${CACHE_FILE}" ]; then
            CAND=$(tr -d ' \r\n' < ${CACHE_FILE} || true)
            if [[ "$CAND" =~ ^[0-9]{1,3}(\.[0-9]{1,3}){3}$ ]]; then
              BEST="$CAND"
              echo "‚úÖ Using cached IP: $BEST"
            else
              echo "‚ùå Cached value invalid or empty: '$CAND'"
            fi
          fi

          if [ -z "${BEST:-}" ]; then
            echo "‚ùå FATAL: No best IP found from scan or cache. Aborting job."
            # leave scan.log for artifact upload (next step runs always)
            exit 1
          fi

          echo "$BEST" > ${CACHE_FILE}
          echo "bestip=${BEST}" >> "$GITHUB_OUTPUT"

      - name: Upload scan.log for debugging
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: scan-log-${{ github.run_id }}
          path: scan.log

      - name: Update Cloudflare Worker Variable (service vars)
        env:
          CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
          CF_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
          CF_WORKER_NAME: ${{ secrets.CF_WORKER_NAME }}
          CF_VAR_NAME: ${{ secrets.CF_VAR_NAME }}
          BESTIP: ${{ steps.scan.outputs.bestip }}
          CF_ENVIRONMENT: ${{ env.CF_ENVIRONMENT }}
        run: |
          set -euo pipefail

          echo "üîê Validating required inputs..."
          : "${BESTIP:?BESTIP is required (from previous step)}"
          : "${CF_ACCOUNT_ID:?CF_ACCOUNT_ID is required}"
          : "${CF_API_TOKEN:?CF_API_TOKEN is required}"
          : "${CF_WORKER_NAME:?CF_WORKER_NAME is required}"
          : "${CF_VAR_NAME:?CF_VAR_NAME is required}"
          : "${CF_ENVIRONMENT:?CF_ENVIRONMENT is required}"

          GET_API_URL="https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/workers/services/${CF_WORKER_NAME}/environments/${CF_ENVIRONMENT}"
          PUT_API_URL="${GET_API_URL}/settings"

          echo "üì° Fetching existing configuration from Cloudflare..."
          RESPONSE=$(curl -s -X GET "$GET_API_URL" \
            -H "Authorization: Bearer ${CF_API_TOKEN}" \
            -H "Content-Type: application/json")

          if ! echo "$RESPONSE" | jq -e '.success == true' > /dev/null; then
            echo "‚ùå Cloudflare GET failed. Response:"
            echo "$RESPONSE"
            exit 1
          fi

          VARS_JSON=$(echo "$RESPONSE" | jq '.result.settings.vars // {}')
          SECRETS_JSON=$(echo "$RESPONSE" | jq '.result.settings.secrets // {}')

          UPDATED_VARS=$(echo "$VARS_JSON" | jq --arg name "$CF_VAR_NAME" --arg value "$BESTIP" '. | .[$name] = $value')

          FINAL_PAYLOAD=$(jq -n --argjson vars "$UPDATED_VARS" --argjson secrets "$SECRETS_JSON" '{ "vars": $vars, "secrets": $secrets }')

          echo "üì° Sending PUT request to update Worker service settings..."
          PUT_RESPONSE=$(curl -s -w "\n%{http_code}" -X PUT "$PUT_API_URL" \
            -H "Authorization: Bearer ${CF_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "$FINAL_PAYLOAD")

          HTTP_CODE=$(echo "$PUT_RESPONSE" | tail -n1)
          BODY=$(echo "$PUT_RESPONSE" | sed '$d')

          if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
            echo "‚ùå Cloudflare API Error (HTTP: $HTTP_CODE). Body:"
            echo "$BODY"
            echo "üí° Ensure CF_API_TOKEN has permission 'workers.services:edit' (or equivalent) and CF_WORKER_NAME is the exact service name."
            exit 1
          fi

          echo "‚úÖ Cloudflare Worker Variable '${CF_VAR_NAME}' updated successfully in '${CF_ENVIRONMENT}'."

  cleanup-runs:
    runs-on: ubuntu-latest
    needs: update-proxy-variable
    if: always()
    permissions:
      actions: write
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          retain_days: 0
          keep_minimum_runs: 0
