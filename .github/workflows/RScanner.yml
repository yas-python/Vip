# Rust Proxy Scanner (Ultimate) - KV Update (final, robust, improved scan parsing)
name: Rust Proxy Scanner (Ultimate) - KV Update

on:
  workflow_dispatch:
  schedule:
    - cron: '0 * * * *'

concurrency:
  group: rust-proxy-scan-final-plaintext
  cancel-in-progress: true

permissions:
  contents: read
  actions: write

env:
  CARGO_TERM_COLOR: always
  CACHE_FILE: .cachelastbestip.txt
  RUST_CACHE_KEY: v4
  CF_ENVIRONMENT: production
  SCAN_BINARY: ./target/release/RScanner
  SCAN_LOG: scan.log
  MAX_CF_RETRIES: "5"
  CF_RETRY_BASE_SLEEP: "2"
  SCANNER_TIMEOUT: "600"

jobs:
  update-proxy-variable:
    name: Build ‚Üí Scan ‚Üí Update Cloudflare KV (RScanner ‚Üí CF REST API)
    runs-on: ubuntu-latest
    timeout-minutes: 45
    outputs:
      bestip: ${{ steps.scan.outputs.bestip }}

    steps:
      - name: Checkout repository (full)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install system dependencies
        run: |
          set -euo pipefail
          echo "=> Updating package lists..."
          sudo apt-get update -y
          echo "=> Installing required packages..."
          sudo apt-get install -y jq curl netcat-openbsd build-essential pkg-config libssl-dev ca-certificates coreutils

      - name: Restore Best IP Cache
        uses: actions/cache@v4
        id: ip-cache
        with:
          path: ${{ env.CACHE_FILE }}
          key: rust-proxy-scanner-best-ip-cache-${{ env.RUST_CACHE_KEY }}-${{ runner.os }}
          restore-keys: |
            rust-proxy-scanner-best-ip-cache-${{ env.RUST_CACHE_KEY }}-
            rust-proxy-scanner-best-ip-cache-

      - name: Install Rust toolchain (stable)
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Cache Rust artifacts and registry
        uses: actions/cache@v4
        with:
          path: |
            target
            ~/.cargo/registry
            ~/.cargo/git
          key: rust-cache-${{ env.RUST_CACHE_KEY }}-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            rust-cache-${{ env.RUST_CACHE_KEY }}-${{ runner.os }}-

      - name: Build Rust project (release)
        run: |
          set -euo pipefail
          echo "=> Starting cargo build --release"
          if ! cargo build --release 2>&1 | tee build-output.log; then
            echo "‚ùå Cargo build failed. Showing last 200 lines:"
            tail -n 200 build-output.log || true
            exit 1
          fi
          echo "‚úÖ Cargo build completed successfully"
          ls -lah target/release/ || true
          if [ -f "${{ env.SCAN_BINARY }}" ]; then
            echo "‚úÖ Scanner binary exists: ${{ env.SCAN_BINARY }}"
          else
            echo "‚ùå ERROR: Scanner binary not found at ${{ env.SCAN_BINARY }}"
            exit 1
          fi

      - name: Run scanner and select best IP (Lowest Ping)
        id: scan
        timeout-minutes: 15
        run: |
          # Robust scan step inspired by the second script's parsing logic.
          set -euo pipefail
          echo "=== Scanner execution started ==="
          BIN="${{ env.SCAN_BINARY }}"
          LOG="${{ env.SCAN_LOG }}"
          CACHE_FILE="${{ env.CACHE_FILE }}"
          TIMEOUT="${{ env.SCANNER_TIMEOUT }}"

          # Temporary files (will be removed on exit)
          TMPDIR=$(mktemp -d)
          CANDIDATES="$TMPDIR/candidates.txt"
          UNSORTED="$TMPDIR/unsorted_candidates.txt"
          SCAN_OUT="$TMPDIR/scan_out.log"

          cleanup() {
            rm -rf "$TMPDIR" || true
          }
          trap cleanup EXIT

          : > "$LOG"
          : > "$SCAN_OUT"
          if [ ! -f "$BIN" ]; then
            echo "‚ùå FATAL: Scanner binary not found at $BIN"
            ls -la target/release/ || true
            exit 1
          fi
          chmod +x "$BIN"

          # Run scanner with timeout but don't fail the step immediately if scanner exits non-zero.
          set +e
          echo "=> Running scanner (timeout ${TIMEOUT}s)..."
          timeout "${TIMEOUT}s" "$BIN" > "$SCAN_OUT" 2>&1
          SCANNER_EXIT_CODE=$?
          set -e

          if [ "$SCANNER_EXIT_CODE" -eq 0 ]; then
            echo "‚úÖ Scanner completed successfully"
          elif [ "$SCANNER_EXIT_CODE" -eq 124 ]; then
            echo "‚ö†Ô∏è Scanner timed out after ${TIMEOUT}s"
          else
            echo "‚ö†Ô∏è Scanner exited with code ${SCANNER_EXIT_CODE} (non-fatal ‚Äî will try to parse partial results)"
          fi

          # Save full scanner output to main log (artifact)
          cp "$SCAN_OUT" "$LOG" || true

          # Parse lines containing "PROXY LIVE" (case-insensitive) and extract latency(ms) and IP.
          # Output format: "<latency> <ip>"
          awk 'BEGIN{IGNORECASE=1}
            /PROXY[[:space:]]+LIVE/ {
              # extract latency in ms from "(123 ms)" or "(123ms)"
              if (match($0, /\(([[:space:]]*([0-9]+)[[:space:]]*m?s)[[:space:]]*\)/, a)) {
                lat = a[2];
                gsub(/[^0-9]/,"",lat);
              } else if (match($0, /\(([0-9]+)[[:space:]]*m?s\)/, b)) {
                lat = b[1];
              } else next;
              # extract IPv4
              if (match($0, /([0-9]{1,3}(\.[0-9]{1,3}){3})/, ip)) {
                split(ip[1], oct, ".")
                valid = 1
                for (i in oct) {
                  if (oct[i] < 0 || oct[i] > 255) valid = 0
                }
                if (valid && lat+0 > 0) print lat+0, ip[1]
              }
            }' "$SCAN_OUT" > "$UNSORTED" || true

          # If some scanners print latency with "ms)" variants or different spacing the awk above handles common cases.
          # Sort numerically by latency; avoid broken-pipe by writing to a file then cutting to top 20.
          if [ -s "$UNSORTED" ]; then
            sort -n -k1,1 "$UNSORTED" > "$CANDIDATES" || cp "$UNSORTED" "$CANDIDATES" || true
            # Keep only top 20 candidates (if present)
            head -n 20 "$CANDIDATES" > "$TMPDIR/candidates_top20.txt" || true
            mv "$TMPDIR/candidates_top20.txt" "$CANDIDATES" || true
          else
            : > "$CANDIDATES"
          fi

          CANDIDATES_COUNT=$(wc -l < "$CANDIDATES" 2>/dev/null || echo 0)
          echo "=> Found ${CANDIDATES_COUNT} valid candidate IPs"
          if [ "$CANDIDATES_COUNT" -gt 0 ]; then
            # Choose best (lowest latency) ‚Äî first line after numeric sort
            BEST_LATENCY=$(awk 'NR==1{print $1}' "$CANDIDATES" || true)
            BEST_IP=$(awk 'NR==1{print $2}' "$CANDIDATES" || true)
            echo "üéØ Best IP selected (lowest ping): ${BEST_IP} with ${BEST_LATENCY}ms"
          else
            BEST_IP=""
            BEST_LATENCY=""
            echo "üü° No live proxies found in current scan results"
          fi

          # If nothing found, attempt to use cached IP (with validation)
          if [ -z "${BEST_IP:-}" ] && [ -f "${CACHE_FILE}" ]; then
            echo "üîÅ Attempting to use cached IP as fallback..."
            CACHED_IP=$(tr -d ' \r\n\t' < "${CACHE_FILE}" 2>/dev/null || true)
            if [[ "$CACHED_IP" =~ ^[0-9]{1,3}(\.[0-9]{1,3}){3}$ ]]; then
              IFS='.' read -ra OCTETS <<< "$CACHED_IP"
              VALID=true
              for octet in "${OCTETS[@]}"; do
                if [ "$octet" -lt 0 ] || [ "$octet" -gt 255 ]; then
                  VALID=false
                  break
                fi
              done
              if [ "$VALID" = true ]; then
                BEST_IP="$CACHED_IP"
                echo "‚úÖ Using cached IP: $BEST_IP"
              else
                echo "‚ö†Ô∏è Cached IP invalid: ${CACHED_IP}"
              fi
            else
              echo "‚ö†Ô∏è Cache contains invalid IP format: ${CACHED_IP}"
            fi
          fi

          if [ -z "${BEST_IP:-}" ]; then
            echo "‚ùå FATAL: No valid IP available from scan or cache"
            echo "=== Last 200 lines of scanner log ==="
            tail -n 200 "$LOG" || true
            exit 1
          fi

          # Save chosen best IP into cache and GitHub output
          echo -n "${BEST_IP}" > "${CACHE_FILE}"
          # Append to GITHUB_OUTPUT properly
          echo "bestip=${BEST_IP}" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Scanner step completed successfully"

      - name: Upload scan.log for debugging (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: scan-log-${{ github.run_id }}
          path: ${{ env.SCAN_LOG }}
          retention-days: 7
          if-no-files-found: warn

      - name: Upload candidates file for debugging
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: candidates-${{ github.run_id }}
          path: candidates.txt
          retention-days: 7
          if-no-files-found: ignore

      - name: Install Wrangler CLI (kept for compatibility; not required for KV write)
        run: |
          set -euo pipefail
          echo "=> Installing Wrangler CLI using npm..."
          npm install -g wrangler@latest || true
          wrangler --version || true

      - name: Update Cloudflare KV via Cloudflare REST API (curl) with verification & retries
        id: update-kv
        env:
          CF_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
          CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
          CF_KV_NAMESPACE_ID: ${{ secrets.CF_KV_NAMESPACE_ID }}
          CF_VAR_KEY: ${{ secrets.CF_VAR_KEY }}
          CF_VAR_VALUE: ${{ steps.scan.outputs.bestip }}
        run: |
          set -euo pipefail
          echo "=== Cloudflare KV update (REST API) started ==="
          # Required env check
          for var in CF_API_TOKEN CF_ACCOUNT_ID CF_KV_NAMESPACE_ID CF_VAR_KEY CF_VAR_VALUE; do
            if [ -z "${!var}" ]; then
              echo "‚ùå ERROR: $var is not set"
              exit 1
            fi
          done
          echo "‚úÖ Required env vars present"

          API_BASE="https://api.cloudflare.com/client/v4"
          NAMESPACE_ID="${CF_KV_NAMESPACE_ID}"
          ACCOUNT_ID="${CF_ACCOUNT_ID}"
          KEY="${CF_VAR_KEY}"
          VALUE="${CF_VAR_VALUE}"
          AUTH_HEADER="Authorization: Bearer ${CF_API_TOKEN}"

          # 1) Verify namespace exists (list namespaces and check)
          echo "=> Verifying KV namespace exists under account ${ACCOUNT_ID}..."
          ns_list=$(curl -sSf -H "${AUTH_HEADER}" "${API_BASE}/accounts/${ACCOUNT_ID}/storage/kv/namespaces" ) || {
            echo "‚ùå Failed to list KV namespaces. Response:"
            curl -s -D - -H "${AUTH_HEADER}" "${API_BASE}/accounts/${ACCOUNT_ID}/storage/kv/namespaces" || true
            exit 1
          }
          if ! echo "$ns_list" | jq -e --arg nsid "$NAMESPACE_ID" '.result[] | select(.id==$nsid)' >/dev/null 2>&1; then
            echo "‚ùå ERROR: Namespace ID ${NAMESPACE_ID} not found in account ${ACCOUNT_ID}"
            echo "=> Available namespaces (first 20):"
            echo "$ns_list" | jq -r '.result[] | "\(.id)\t\(.title)"' | head -n 20 || true
            exit 1
          fi
          echo "‚úÖ Namespace ${NAMESPACE_ID} verified."

          # 2) Put key (use retries)
          put_url="${API_BASE}/accounts/${ACCOUNT_ID}/storage/kv/namespaces/${NAMESPACE_ID}/values/${KEY}"
          attempt=0
          max_attempts=${MAX_CF_RETRIES:-5}
          sleep_base=${CF_RETRY_BASE_SLEEP:-2}

          echo "=> Attempting to PUT key '${KEY}' => '${VALUE}' into namespace ${NAMESPACE_ID}"

          while [ $attempt -lt $max_attempts ]; do
            attempt=$((attempt+1))
            echo "=> PUT attempt $attempt/$max_attempts..."
            http_status=$(curl -s -o /tmp/cf_put_resp -w "%{http_code}" -X PUT \
              -H "Authorization: Bearer ${CF_API_TOKEN}" \
              -H "Content-Type: text/plain" \
              --data-binary "${VALUE}" \
              "${put_url}" || echo "000")

            if [ "$http_status" = "200" ] || [ "$http_status" = "201" ] || [ "$http_status" = "204" ]; then
              echo "‚úÖ PUT successful (HTTP ${http_status})"
              break
            else
              echo "‚ö†Ô∏è PUT returned HTTP ${http_status}"
              if [ -s /tmp/cf_put_resp ]; then
                echo "=> Response body:"
                head -n 200 /tmp/cf_put_resp || true
              fi
              if [ $attempt -lt $max_attempts ]; then
                sleep_seconds=$(( sleep_base * attempt ))
                echo "=> Retrying in ${sleep_seconds}s..."
                sleep $sleep_seconds
              else
                echo "‚ùå All PUT attempts failed. Exiting."
                exit 1
              fi
            fi
          done

          # 3) Verify by GET
          echo "=> Verifying stored value with GET..."
          get_url="${API_BASE}/accounts/${ACCOUNT_ID}/storage/kv/namespaces/${NAMESPACE_ID}/values/${KEY}"
          http_status=$(curl -s -o /tmp/cf_get_resp -w "%{http_code}" -H "Authorization: Bearer ${CF_API_TOKEN}" "${get_url}" || echo "000")
          if [ "$http_status" = "200" ]; then
            stored_value=$(cat /tmp/cf_get_resp | tr -d '\r\n\t ')
            if [ "$stored_value" = "$VALUE" ]; then
              echo "‚úÖ KV verification passed. Value matches: ${stored_value}"
            else
              echo "‚ö†Ô∏è KV verification mismatch. Stored:'${stored_value}' Expected:'${VALUE}'"
              echo "=> Forcing success exit but please inspect logs. (You can change this to exit 1 if strict)"
              # If you want to fail the workflow on mismatch, uncomment next line:
              # exit 1
            fi
          else
            echo "‚ö†Ô∏è GET returned HTTP ${http_status} ‚Äî could not verify value."
            if [ -s /tmp/cf_get_resp ]; then head -n 200 /tmp/cf_get_resp; fi
            # optionally fail:
            # exit 1
          fi

          echo "bestip=${VALUE}" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Cloudflare KV REST API update completed."
          echo "=== Final IP in KV: ${VALUE} ==="

      - name: Upload Cloudflare REST API logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: cf-rest-logs-${{ github.run_id }}
          path: /tmp/cf_*.log,/tmp/cf_put_resp,/tmp/cf_get_resp
          retention-days: 7
          if-no-files-found: ignore

  post-cache-artifacts:
    name: Post Cache Rust artifacts & registry
    runs-on: ubuntu-latest
    needs: update-proxy-variable
    if: always()
    steps:
      - name: Cache maintenance completed
        run: echo "Cache maintenance completed."

  post-restore-ip-cache:
    name: Post Restore Best IP Cache
    runs-on: ubuntu-latest
    needs: update-proxy-variable
    if: always()
    steps:
      - name: IP cache status
        run: echo "Best IP cache has been updated for subsequent workflow runs"

  cleanup-runs:
    name: Post Checkout repository (full)
    runs-on: ubuntu-latest
    needs: update-proxy-variable
    if: always()
    permissions:
      actions: write
      contents: read
    steps:
      - name: Checkout for cleanup
        uses: actions/checkout@v4

      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          retain_days: 0
          keep_minimum_runs: 0

  complete-job:
    name: Complete job
    runs-on: ubuntu-latest
    needs: update-proxy-variable
    if: always()
    steps:
      - name: Workflow execution summary
        run: |
          echo "=== Workflow Execution Summary ==="
          echo "=> Best IP selected: ${{ needs.update-proxy-variable.outputs.bestip }}"
          echo "=> Workflow Status: Complete"
          echo "=> Check artifacts for detailed logs"
