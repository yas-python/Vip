name: Rust Proxy Scanner (Ultimate)
on:
  workflow_dispatch:
  schedule:
    - cron: '0 */1 * * *'  # every hour

concurrency:
  group: rust-proxy-scan
  cancel-in-progress: true

env:
  KEEP_DEPLOYMENTS: '5'
  ONLY_IP: 'true'
  CACHE_FILE: .cachelastbestip.txt

jobs:
  update-proxies:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      bestip: ${{ steps.scan.outputs.bestip }}
      raw_best: ${{ steps.scan.outputs.raw_best }}
      best_latency: ${{ steps.scan.outputs.best_latency }}

    steps:
    - name: Checkout repo
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Setup environment (install tools & Python deps)
      run: |
        set -euo pipefail
        sudo apt-get update -y
        sudo apt-get install -y jq curl ca-certificates python3 python3-pip netcat-openbsd
        python3 -m pip install --no-cache-dir requests
    
    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable
    
    - name: Build Rust project (release)
      run: |
        set -euo pipefail
        cargo build --release
    
    - name: Run scanner and choose best (produce scan.log & bestproxy)
      id: scan
      run: |
        set -euo pipefail
        BIN="./target/release/RScanner"
        chmod +x "$BIN" || true
        : > scan.log
        if ! $BIN 2>&1 | tee -a scan.log; then
          echo "WARN: scanner failed; attempting partial parse / using cache."
        fi
        BEST=""
        BEST_LAT=""
        if [ -f bestproxy.txt ]; then
          BEST="$(tr -d ' \r\n' < bestproxy.txt || true)"
        fi
        if [ -z "$BEST" ]; then
          awk '
            BEGIN{IGNORECASE=1}
            /PROXY[[:space:]]+LIVE/ {
              line=$0
              if (match(line, /([0-9]+)[[:space:]]*ms/, lat)) { latency=lat[1] }
              else if (match(line, /\(([0-9]+)[[:space:]]*ms\)/, lat)) { latency=lat[1] }
              else next
              if (match(line, /(\[[0-9a-fA-F:]+\](:[0-9]{1,5})?)/, addr)) { ip=addr[1] }
              else if (match(line, /([0-9]{1,3}(\.[0-9]{1,3}){3}(:[0-9]{1,5})?)/, addr)) { ip=addr[1] }
              else next
              print latency, ip
            }
          ' scan.log | sort -n -k1,1 > candidates.txt || true
          if [ -s candidates.txt ]; then
            BEST_LAT=$(awk 'NR==1{print $1}' candidates.txt)
            BEST=$(awk 'NR==1{print $2}' candidates.txt)
            echo "Selected candidate from log: $BEST (lat ${BEST_LAT} ms)"
          else
            echo "No candidates parsed from scan.log"
          fi
        fi
        if [ -z "$BEST" ] && [ -f "${CACHE_FILE}" ]; then
          BEST="$(tr -d ' \r\n' < ${CACHE_FILE} || true)"
          echo "Using cached BEST: $BEST"
        fi
        if [ -z "${BEST:-}" ]; then
          echo "ERROR: No best candidate found"
          sed -n '1,200p' scan.log || true
          exit 1
        fi
        BEST_CLEAN="$(echo "$BEST" | sed -E 's/^\[//; s/\](:[0-9]+)?$//; s/:([0-9]+)$//')"
        HOST_ONLY="$(echo "$BEST" | sed -E 's/^\[//; s/\](:[0-9]+)?$//; s/:([0-9]+)$//')"
        PORT_PART="$(echo "$BEST" | awk -F: '{ if (NF>1) print $NF; else print "" }')"
        if [ -n "$PORT_PART" ] && command -v nc >/dev/null 2>&1; then
          if nc -z -w 2 "$HOST_ONLY" "$PORT_PART" >/dev/null 2>&1; then
            echo "TCP port reachable"
          else
            echo "WARN: TCP port not reachable (continuing anyway)"
          fi
        else
          if command -v ping >/dev/null 2>&1; then
            if ping -c 1 -W 1 "$HOST_ONLY" >/dev/null 2>&1; then
              echo "ICMP reachable"
            else
              echo "WARN: ICMP not reachable (continuing anyway)"
            fi
          fi
        fi
        echo "$BEST" > ${CACHE_FILE}
        echo "bestip=$BEST_CLEAN" >> "$GITHUB_OUTPUT"
        echo "raw_best=$BEST" >> "$GITHUB_OUTPUT"
        echo "best_latency=${BEST_LAT:-}" >> "$GITHUB_OUTPUT"
        echo "Scanner result: $BEST (clean: $BEST_CLEAN)"
    
    - name: Upload scan.log for debug (artifact)
      uses: actions/upload-artifact@v4
      with:
        name: scan-log
        path: scan.log
    
    - name: Commit & push cache/report if changed
      run: |
        set -euo pipefail
        git config --global user.name "NET Sentinel Bot"
        git config --global user.email "224584266+NetSentinel-Bot@users.noreply.github.com"
        git add ${CACHE_FILE} || true
        if ! git diff --cached --quiet; then
          git commit -m "Proxy update at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" || true
          git push origin HEAD:${GITHUB_REF#refs/heads/} || true
        else
          echo "No changes to commit"
        fi
    
    - name: Update Cloudflare Pages env var (securely from secrets)
      env:
        CFACCOUNTID: ${{ secrets.CF_ACCOUNT_ID }}
        CFTOKEN: ${{ secrets.CF_API_TOKEN }}
        CFPROJECT: ${{ secrets.CF_PROJECT_NAME }}
        CFVAR: ${{ secrets.CF_VAR_NAME }}
        BESTIP: ${{ steps.scan.outputs.bestip }}
      run: |
        set -euo pipefail
        if [ -z "${BESTIP:-}" ]; then
          echo "ERROR: BESTIP empty; aborting Cloudflare update."
          exit 1
        fi
        if [ -z "${CFACCOUNTID:-}" ]  [ -z "${CFTOKEN:-}" ]  [ -z "${CFPROJECT:-}" ] || [ -z "${CFVAR:-}" ]; then
          echo "ERROR: missing required CF secrets"
          exit 1
        fi
        url="https://api.cloudflare.com/client/v4/accounts/${CFACCOUNTID}/pages/projects/${CFPROJECT}"
        payload=$(jq -n --arg name "$CFPROJECT" --arg varname "$CFVAR" --arg val "$BESTIP" \
          '{name:$name, env_vars: { ($varname): {value:$val, type:"plaintext"} } }')
        echo "PATCH $url -> set ${CFVAR}=${BESTIP}"
        for i in 1 2 3 4 5; do
          resp=$(curl -sS -X PATCH "$url" \
            -H "Authorization: Bearer ${CFTOKEN}" \
            -H "Content-Type: application/json" \
            --data "$payload" || true)
          if [ -n "$resp" ]; then
            ok=$(echo "$resp" | jq -r '.success // false')
            if [ "$ok" = "true" ]; then
              echo "Cloudflare variable updated successfully."
              echo "$resp" | jq .
              break
            else
              echo "Attempt $i: CF API returned non-success. Body:"
              echo "$resp" | jq -C .
            fi
          else
            echo "Attempt $i: empty response"
          fi
          sleep $((2**i))
        done
    
    - name: Trigger Cloudflare Pages deploy (optional)
      if: ${{ success() }}
      env:
        CFACCOUNTID: ${{ secrets.CF_ACCOUNT_ID }}
        CFTOKEN: ${{ secrets.CF_API_TOKEN }}
        CFPROJECT: ${{ secrets.CF_PROJECT_NAME }}
      run: |
        set -euo pipefail
        url="https://api.cloudflare.com/client/v4/accounts/${CFACCOUNTID}/pages/projects/${CFPROJECT}/deployments"
        for i in 1 2 3 4 5; do
          resp=$(curl -sS -X POST "$url" -H "Authorization: Bearer ${CFTOKEN}" -H "Content-Type: application/json" --data "{}" || true)
          if [ -n "$resp" ] && [ "$(echo "$resp" | jq -r '.success // false')" = "true" ]; then
            echo "Triggered deployment"; break
          fi
          sleep $((2**i))
        done
    
    - name: Cleanup old deployments (keep last N)
      if: ${{ success() }}
      env:
        CFACCOUNTID: ${{ secrets.CF_ACCOUNT_ID }}
        CFTOKEN: ${{ secrets.CF_API_TOKEN }}
        CFPROJECT: ${{ secrets.CF_PROJECT_NAME }}
        KEEP: ${{ env.KEEP_DEPLOYMENTS }}
      run: |
        set -euo pipefail
        KEEP_NUM=${KEEP:-5}
        url="https://api.cloudflare.com/client/v4/accounts/${CFACCOUNTID}/pages/projects/${CFPROJECT}/deployments"
        resp=$(curl -sS -G -H "Authorization: Bearer ${CFTOKEN}" "$url" --data-urlencode "per_page=50" || true)
        if [ -z "$resp" ]; then
          echo "WARN: empty list deployments response; skipping cleanup"; exit 0
        fi
        if [ "$(echo "$resp" | jq -r '.success // false')" != "true" ]; then
          echo "WARN: list deployments failed; skipping cleanup"; exit 0
        fi
        mapfile -t ids < <(echo "$resp" | jq -r '.result | sort_by(.created_on) | reverse | .[].id')
        total=${#ids[@]}
        echo "Found $total deployments, keeping $KEEP_NUM"
        if [ "$total" -le "$KEEP_NUM" ]; then echo "No cleanup needed"; exit 0; fi
        for idx in $(seq ${KEEP_NUM} $((total-1))); do
          id=${ids[$idx]}
          echo "Deleting deployment $id"
          curl -sS -X DELETE "https://api.cloudflare.com/client/v4/accounts/${CFACCOUNTID}/pages/projects/${CFPROJECT}/deployments/${id}" -H "Authorization: Bearer ${CFTOKEN}" || true
        done
    
    - name: Done
      run: echo "Workflow complete"
