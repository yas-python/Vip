name: Rust Proxy Scanner (Ultimate) - KV update    
    
# triggers: manual + hourly    
on:    
  workflow_dispatch:    
  schedule:    
    - cron: '0 * * * *' # every hour    
    
concurrency:    
  group: rust-proxy-scan-final-plaintext    
  cancel-in-progress: true    
    
permissions:    
  contents: read    
  actions: write    
    
env:    
  CARGO_TERM_COLOR: always    
  CACHE_FILE: .cachelastbestip.txt    
  RUST_CACHE_KEY: v4    
  CF_ENVIRONMENT: production    
  SCAN_BINARY: ./target/release/RScanner    
  SCAN_LOG: scan.log    
  MAX_CF_RETRIES: "5"    
  CF_RETRY_BASE_SLEEP: "2"    
    
jobs:    
  update-proxy-variable:    
    name: Build â†’ Scan â†’ Update Cloudflare KV (RScanner)    
    runs-on: ubuntu-latest    
    timeout-minutes: 45    
    outputs:    
      bestip: ${{ steps.scan.outputs.bestip }}    
    
    steps:    
      - name: Checkout repository (full)    
        uses: actions/checkout@v4    
        with:    
          fetch-depth: 0    
    
      - name: Install system deps (jq, curl, build tools, libssl)    
        run: |    
          set -euo pipefail    
          echo "=> apt-get update..."    
          sudo apt-get update -y    
          echo "=> installing packages..."    
          sudo apt-get install -y jq curl netcat-openbsd build-essential pkg-config libssl-dev ca-certificates    
    
      - name: Restore Best IP Cache    
        uses: actions/cache@v4    
        id: ip-cache    
        with:    
          path: ${{ env.CACHE_FILE }}    
          key: rust-proxy-scanner-best-ip-cache-${{ env.RUST_CACHE_KEY }}-${{ runner.os }}    
    
      - name: Install Rust toolchain (stable)    
        uses: dtolnay/rust-toolchain@stable    
        with:    
          toolchain: stable    
    
      - name: Cache Rust artifacts & registry    
        uses: actions/cache@v4    
        with:    
          path: |    
            target    
            ~/.cargo/registry    
            ~/.cargo/git    
          key: rust-cache-${{ env.RUST_CACHE_KEY }}-${{ runner.os }}    
    
      - name: Build Rust project (release)    
        run: |    
          set -euo pipefail    
          echo "=> cargo build --release (start)"    
          if ! cargo build --release 2>&1 | tee build-output.log; then    
            echo "âŒ cargo build failed. Showing last 200 lines from build-output.log"    
            tail -n 200 build-output.log || true    
            exit 1    
          fi    
          echo "âœ… cargo build completed."    
          ls -la target/release || true    
    
      - name: Run scanner and choose best IP    
        id: scan    
        run: |    
          set -euo pipefail    
          echo "=== Scanner step start ==="    
          BIN="${{ env.SCAN_BINARY }}"    
          LOG="${{ env.SCAN_LOG }}"    
          CACHE_FILE="${{ env.CACHE_FILE }}"    
          : > "$LOG"    
    
          echo "â†’ Checking scanner binary at $BIN"    
          if [ ! -f "$BIN" ]; then    
            echo "âŒ FATAL: Scanner executable not found at $BIN"    
            exit 1    
          fi    
    
          chmod +x "$BIN" || true    
          echo "ðŸš€ Running scanner (output â†’ $LOG). Scanner may exit non-zero; we will still attempt to parse results."    
          "$BIN" 2>&1 | tee -a "$LOG" || echo "âš ï¸ Scanner exited with non-zero status; continue to parse log."    
    
          echo "ðŸ” Parsing scan.log for 'PROXY ... LIVE' lines with latency and IPv4"    
          awk '    
            BEGIN{IGNORECASE=1}    
            /PROXY[[:space:]]+LIVE/ {    
              if (match($0, /([0-9]+)[[:space:]]*ms/, lat)) { latency=lat[1] } else next    
              if (match($0, /([0-9]{1,3}(\.[0-9]{1,3}){3})/ , addr)) { ip=addr[1] } else next    
              print latency, ip    
            }    
          ' "$LOG" | sort -n -k1,1 > candidates.txt || true    
    
          BEST=""    
          BEST_LAT=""    
    
          if [ -s candidates.txt ]; then    
            BEST_LAT=$(awk 'NR==1{print $1}' candidates.txt)    
            BEST=$(awk 'NR==1{print $2}' candidates.txt)    
            echo "âœ… Selected best candidate from scan: $BEST (latency ${BEST_LAT} ms)"    
          else    
            echo "ðŸŸ¡ No live proxies parsed from $LOG. Attempting cache fallback..."    
          fi    
    
          # Fallback: cached file    
          if [ -z "${BEST:-}" ] && [ -f "${CACHE_FILE}" ]; then    
            CAND=$(tr -d ' \r\n' < ${CACHE_FILE} || true)    
            echo "ðŸ” Found cache value: '$CAND'"    
            if [[ "$CAND" =~ ^[0-9]{1,3}(\.[0-9]{1,3}){3}$ ]]; then    
              BEST="$CAND"    
              echo "âœ… Using cached IP: $BEST"    
            else    
              echo "âš ï¸ Cached file exists but value invalid: '$CAND'. Ignoring."    
            fi    
          fi    
    
          # Final check for failure    
          if [ -z "${BEST:-}" ]; then    
            echo "âŒ FATAL: No best IP found from scan or cache."    
            tail -n 200 "$LOG" || true    
            exit 1    
          fi    
    
          echo "ðŸ’¾ Persisting best IP to cache file (${CACHE_FILE})"    
          echo "$BEST" > ${CACHE_FILE} || true    
    
          # Export output correctly for GitHub Actions    
          echo "bestip=${BEST}" >> "$GITHUB_OUTPUT"    
          echo "âœ… Scanner step complete. bestip=${BEST}"    
          echo "=== Scanner step end ==="    
    
      - name: Upload scan.log for debugging (always)    
        if: always()    
        uses: actions/upload-artifact@v4    
        with:    
          name: scan-log-${{ github.run_id }}    
          path: ${{ env.SCAN_LOG }}    
    
      # -----------------------    
      # Update Cloudflare KV    
      # -----------------------    
      - name: Update Cloudflare KV (REST API) with retries + health-check    
        id: update-kv    
        env:    
          CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}    
          CF_API_TOKEN: ${{ secrets.CF_API_TOKEN }}    
          CF_KV_NAMESPACE_ID: ${{ secrets.CF_KV_NAMESPACE_ID }}    
          CF_WORKER_NAME: ${{ secrets.CF_WORKER_NAME }}    
          CF_VAR_KEY: ${{ secrets.CF_VAR_KEY }}    
          BESTIP: ${{ steps.scan.outputs.bestip }}    
          MAX_RETRIES: ${{ env.MAX_CF_RETRIES }}    
          BASE_SLEEP: ${{ env.CF_RETRY_BASE_SLEEP }}    
        run: |    
          set -euo pipefail    
          : "${BESTIP:?BESTIP required from scanner}"    
          : "${CF_ACCOUNT_ID:?CF_ACCOUNT_ID is required}"    
          : "${CF_API_TOKEN:?CF_API_TOKEN is required}"    
          : "${CF_KV_NAMESPACE_ID:?CF_KV_NAMESPACE_ID is required}"    
          : "${CF_VAR_KEY:?CF_VAR_KEY is required}"    
          : "${CF_WORKER_NAME:?CF_WORKER_NAME is required}"    
    
          echo "=== Cloudflare KV update step start ==="    
          echo "Setting KV key '${CF_VAR_KEY}' -> '${BESTIP}' in namespace ${CF_KV_NAMESPACE_ID}"    
    
          retry_put() {    
            local attempt=1    
            local max="${MAX_RETRIES:-5}"    
            local base_sleep="${BASE_SLEEP:-2}"    
            while [ "$attempt" -le "$max" ]; do    
              echo "â†’ Attempt #${attempt} to PUT KV"    
              # PUT value (no auth header content-type necessary)    
              response=$(curl -s -w "\n%{http_code}" -X PUT \    
                "https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/storage/kv/namespaces/${CF_KV_NAMESPACE_ID}/values/${CF_VAR_KEY}" \    
                -H "Authorization: Bearer ${CF_API_TOKEN}" \    
                --data-binary "${BESTIP}" ) || response=""    
              http_code=$(echo "$response" | tail -n1)    
              body=$(echo "$response" | sed '$d' || echo "")    
              if [ -n "$http_code" ] && [ "$http_code" -ge 200 ] && [ "$http_code" -lt 300 ]; then    
                echo "â†’ KV PUT succeeded (HTTP ${http_code})."    
                echo "$body"    
                return 0    
              else    
                echo "âš ï¸ KV PUT HTTP ${http_code}. Body (truncated):"    
                echo "$body" | sed -n '1,200p' || true    
                if [ "$attempt" -lt "$max" ]; then    
                  sleep_seconds=$(( base_sleep ** attempt ))    
                  echo "â³ Sleeping ${sleep_seconds}s before retry..."    
                  sleep $sleep_seconds    
                fi    
              fi    
              attempt=$((attempt+1))    
            done    
            echo "âŒ All attempts to PUT KV failed."    
            return 1    
          }    
    
          if ! retry_put; then    
            echo "âŒ Failed to update KV after retries. Aborting to avoid inconsistent state."    
            exit 1    
          fi    
    
          echo "âœ… KV updated to ${BESTIP}. Proceeding to health-check."    
    
          # Health-check loop: try /health endpoint a few times until success    
          HEALTH_URL="https://${CF_WORKER_NAME}.${{ secrets.CF_ACCOUNT_ID }}.workers.dev/health"    
          # If your worker is bound to a domain, replace above with proper URL: https://example.com/health    
          echo "Health-check URL: ${HEALTH_URL}"    
    
          attempt=1    
          max=5    
          while [ "$attempt" -le "$max" ]; do    
            echo "â†’ Healthcheck attempt #${attempt}..."    
            status=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 "${HEALTH_URL}" || echo "000")    
            echo "â†’ HTTP ${status}"    
            if [ "$status" = "200" ]; then    
              echo "âœ… Healthcheck OK."    
              echo "bestip=${BESTIP}" >> "$GITHUB_OUTPUT"    
              exit 0    
            fi    
            sleep 2    
            attempt=$((attempt+1))    
          done    
    
          echo "âš ï¸ Healthcheck failed after ${max} attempts â€” but KV is updated. Please inspect Worker / logs."    
          echo "bestip=${BESTIP}" >> "$GITHUB_OUTPUT"    
          # Do not fail the workflow if healthcheck fails (config updated) â€” but mark as warning    
          exit 0    
    
  cleanup-runs:    
    name: Cleanup old workflow runs    
    runs-on: ubuntu-latest    
    needs: update-proxy-variable    
    if: always()    
    permissions:    
      actions: write    
    steps:    
      - name: Delete old workflow runs (retain 0 days / keep 0)    
        uses: Mattraks/delete-workflow-runs@v2    
        with:    
          token: ${{ secrets.GITHUB_TOKEN }}    
          repository: ${{ github.repository }}    
          retain_days: 0    
          keep_minimum_runs: 0    
