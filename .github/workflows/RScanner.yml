name: Rust Proxy Scanner (Ultimate) - KV Update

on:
  workflow_dispatch:
  schedule:
    - cron: '0 * * * *'

concurrency:
  group: rust-proxy-scan-final-plaintext
  cancel-in-progress: true

permissions:
  contents: read
  actions: write

env:
  CARGO_TERM_COLOR: always
  CACHE_FILE: .cachelastbestip.txt
  RUST_CACHE_KEY: v4
  CF_ENVIRONMENT: production
  SCAN_BINARY: ./target/release/RScanner
  SCAN_LOG: scan.log
  MAX_CF_RETRIES: "5"
  CF_RETRY_BASE_SLEEP: "2"
  SCANNER_TIMEOUT: "600"

jobs:
  update-proxy-variable:
    name: Build → Scan → Update Cloudflare KV (RScanner)
    runs-on: ubuntu-latest
    timeout-minutes: 45
    outputs:
      bestip: ${{ steps.scan.outputs.bestip }}

    steps:
      - name: Checkout repository (full)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install system dependencies
        run: |
          set -euo pipefail
          echo "=> Updating package lists..."
          sudo apt-get update -y
          echo "=> Installing required packages..."
          sudo apt-get install -y jq curl netcat-openbsd build-essential pkg-config libssl-dev ca-certificates coreutils

      - name: Restore Best IP Cache
        uses: actions/cache@v4
        id: ip-cache
        with:
          path: ${{ env.CACHE_FILE }}
          key: rust-proxy-scanner-best-ip-cache-${{ env.RUST_CACHE_KEY }}-${{ runner.os }}
          restore-keys: |
            rust-proxy-scanner-best-ip-cache-${{ env.RUST_CACHE_KEY }}-
            rust-proxy-scanner-best-ip-cache-

      - name: Install Rust toolchain (stable)
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Cache Rust artifacts and registry
        uses: actions/cache@v4
        with:
          path: |
            target
            ~/.cargo/registry
            ~/.cargo/git
          key: rust-cache-${{ env.RUST_CACHE_KEY }}-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            rust-cache-${{ env.RUST_CACHE_KEY }}-${{ runner.os }}-

      - name: Build Rust project (release)
        run: |
          set -euo pipefail
          echo "=> Starting cargo build --release"
          echo "=> Build timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          
          if ! cargo build --release 2>&1 | tee build-output.log; then
            echo "❌ Cargo build failed. Showing last 200 lines:"
            tail -n 200 build-output.log || true
            exit 1
          fi
          
          echo "✅ Cargo build completed successfully"
          ls -lah target/release/ || true
          
          if [ -f "${{ env.SCAN_BINARY }}" ]; then
            file "${{ env.SCAN_BINARY }}" || true
            echo "✅ Scanner binary verified"
          else
            echo "❌ ERROR: Scanner binary not found at ${{ env.SCAN_BINARY }}"
            exit 1
          fi

      - name: Run scanner and select best IP
        id: scan
        timeout-minutes: 15
        run: |
          set -euo pipefail
          echo "=== Scanner execution started ==="
          echo "=> Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          
          BIN="${{ env.SCAN_BINARY }}"
          LOG="${{ env.SCAN_LOG }}"
          CACHE_FILE="${{ env.CACHE_FILE }}"
          TIMEOUT="${{ env.SCANNER_TIMEOUT }}"
          
          : > "$LOG"

          if [ ! -f "$BIN" ]; then
            echo "❌ FATAL: Scanner binary not found at $BIN"
            ls -la target/release/ || true
            exit 1
          fi

          chmod +x "$BIN"
          
          echo "🚀 Executing scanner (timeout: ${TIMEOUT}s)"
          
          # Run scanner and capture output properly without pipe breaking
          set +e
          timeout "${TIMEOUT}s" "$BIN" > "$LOG" 2>&1
          SCANNER_EXIT=$?
          set -e
          
          if [ $SCANNER_EXIT -eq 0 ]; then
            echo "✅ Scanner completed successfully"
          elif [ $SCANNER_EXIT -eq 124 ]; then
            echo "⚠️ Scanner timed out after ${TIMEOUT}s"
            echo "=> Attempting to parse available results..."
          else
            echo "⚠️ Scanner exited with code $SCANNER_EXIT"
            echo "=> Attempting to parse available results..."
          fi

          echo "=> Scanner finished at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "=> Log contains $(wc -l < "$LOG" 2>/dev/null || echo 0) lines"

          echo "🔍 Parsing results for live proxies..."
          
          # Extract IP and latency pairs more reliably
          grep -i "PROXY.*LIVE" "$LOG" | \
            grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}.*\([0-9]+[[:space:]]*ms\)' | \
            sed -E 's/^.*([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}).*\(([0-9]+)[[:space:]]*ms\).*/\2 \1/' | \
            grep -E '^[0-9]+ ([0-9]{1,3}\.){3}[0-9]{1,3}$' > unsorted_candidates.txt || touch unsorted_candidates.txt
          
          # Sort by latency (first column) and take top 20
          if [ -s unsorted_candidates.txt ]; then
            sort -n -k1,1 unsorted_candidates.txt | head -n 20 > candidates.txt 2>/dev/null || {
              echo "⚠️ Sort command failed, using unsorted data"
              head -n 20 unsorted_candidates.txt > candidates.txt
            }
          else
            touch candidates.txt
          fi

          CANDIDATES_COUNT=$(wc -l < candidates.txt 2>/dev/null || echo 0)
          echo "=> Found ${CANDIDATES_COUNT} valid candidate IPs"
          
          if [ "$CANDIDATES_COUNT" -gt 0 ]; then
            echo "=> Top 5 candidates:"
            head -n 5 candidates.txt | while read -r lat ip; do
              echo "   • $ip (${lat}ms)"
            done
          fi

          BEST=""
          BEST_LAT=""

          # Select IP with lowest latency
          if [ -s candidates.txt ]; then
            read -r BEST_LAT BEST < candidates.txt
            echo "✅ Best IP from current scan: $BEST (${BEST_LAT}ms)"
          else
            echo "🟡 No live proxies found in scan results"
          fi

          # Fallback to cached IP if no new IP found
          if [ -z "${BEST}" ] && [ -f "${CACHE_FILE}" ]; then
            echo "🔁 Attempting to use cached IP..."
            CACHED=$(tr -d ' \r\n\t' < "${CACHE_FILE}" 2>/dev/null || true)
            
            if [[ "$CACHED" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
              BEST="$CACHED"
              echo "✅ Using cached IP: $BEST"
            else
              echo "⚠️ Cache contains invalid IP format"
            fi
          fi

          # Fatal error if no valid IP available
          if [ -z "${BEST}" ]; then
            echo "❌ FATAL: No valid IP available"
            echo "=> Scan log preview (last 100 lines):"
            tail -n 100 "$LOG" || true
            exit 1
          fi

          # Validate IP format
          if ! [[ "$BEST" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
            echo "❌ FATAL: Invalid IP format: $BEST"
            exit 1
          fi

          # Save to cache
          echo "💾 Saving best IP to cache"
          echo -n "$BEST" > "${CACHE_FILE}"
          
          if [ -f "${CACHE_FILE}" ]; then
            VERIFY=$(cat "${CACHE_FILE}")
            echo "=> Cache verified: $VERIFY"
          fi

          # Output for next steps
          echo "bestip=${BEST}" >> "$GITHUB_OUTPUT"
          echo "✅ Scanner step completed"
          echo "=> Selected IP: ${BEST}"
          [ -n "${BEST_LAT}" ] && echo "=> Latency: ${BEST_LAT}ms"
          echo "=== Scanner execution ended ==="

      - name: Upload scan.log for debugging (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: scan-log-${{ github.run_id }}
          path: ${{ env.SCAN_LOG }}
          retention-days: 7
          if-no-files-found: warn

      - name: Upload candidates file for debugging
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: candidates-${{ github.run_id }}
          path: candidates.txt
          retention-days: 7
          if-no-files-found: ignore

      - name: Update Cloudflare KV (REST API) with retries + health-check
        id: update-kv
        env:
          CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
          CF_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
          CF_KV_NAMESPACE_ID: ${{ secrets.CF_KV_NAMESPACE_ID }}
          CF_WORKER_NAME: ${{ secrets.CF_WORKER_NAME }}
          CF_VAR_KEY: ${{ secrets.CF_VAR_KEY }}
          BESTIP: ${{ steps.scan.outputs.bestip }}
          MAX_RETRIES: ${{ env.MAX_CF_RETRIES }}
          BASE_SLEEP: ${{ env.CF_RETRY_BASE_SLEEP }}
        run: |
          set -euo pipefail
          
          echo "=== Cloudflare KV update started ==="
          echo "=> Start time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "=> Configuration:"
          echo "   • KV Namespace: ***${CF_KV_NAMESPACE_ID: -4}"
          echo "   • KV Key: ${CF_VAR_KEY}"
          echo "   • Best IP: ${BESTIP}"
          echo "   • Rest IP: 20.63.17.53 (1615ms)"
          echo "   • Worker: ${CF_WORKER_NAME}"
          
          # Validate required environment variables
          for var in CF_ACCOUNT_ID CF_API_TOKEN CF_KV_NAMESPACE_ID CF_VAR_KEY BESTIP; do
            if [ -z "${!var}" ]; then
              echo "❌ ERROR: $var is not set"
              exit 1
            fi
          done

          echo "=> All required environment variables validated"

          retry_kv_put() {
            local attempt=1
            local max_attempts="${MAX_RETRIES:-5}"
            local base_sleep_time="${BASE_SLEEP:-2}"
            
            while [ "$attempt" -le "$max_attempts" ]; do
              echo ""
              echo "→ Attempt #${attempt}/${max_attempts} to PUT KV value"
              echo "   URL:"
              echo "   https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/storage/kv/namespaces/${CF_KV_NAMESPACE_ID}/values/${CF_VAR_KEY}"
              
              local response_file
              response_file=$(mktemp)
              
              local http_code
              http_code=$(curl -s -w "%{http_code}" -X PUT \
                "https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/storage/kv/namespaces/${CF_KV_NAMESPACE_ID}/values/${CF_VAR_KEY}" \
                -H "Authorization: Bearer ${CF_API_TOKEN}" \
                -H "Content-Type: text/plain" \
                --data "${BESTIP}" \
                --max-time 10 \
                --connect-timeout 5 \
                -o "$response_file" 2>&1 || echo "000")
              
              local response_body
              response_body=$(cat "$response_file" 2>/dev/null || echo "")
              rm -f "$response_file"
              
              echo "   • HTTP Status: ${http_code}"
              
              if [ "$http_code" = "200" ] || [ "$http_code" = "204" ]; then
                echo "✅ Cloudflare KV update completed successfully"
                if [ -n "$response_body" ]; then
                  echo "   • Response: $(echo "$response_body" | head -c 200)"
                fi
                return 0
              fi
              
              echo "⚠️ KV PUT failed (HTTP ${http_code})"
              if [ -n "$response_body" ]; then
                echo "   • Response body (first 500 chars):"
                echo "$response_body" | head -c 500
                echo ""
              fi
              
              # Handle specific error codes
              case "$http_code" in
                401|403)
                  echo "❌ FATAL: KV update failed after all retries"
                  echo "=> This likely indicates a configuration or authentication problem"
                  echo "=> Please verify:"
                  echo "   1. Verify CF_API_TOKEN has 'Account.Workers KV Storage:Edit' permission"
                  echo "   2. CF_ACCOUNT_ID matches your cloudflare account"
                  echo "   3. Check CF_KV_NAMESPACE_ID exists: wrangler kv:namespace list"
                  echo "   4. Ensure KV namespace is NOT bound to a worker (unbind if necessary)"
                  echo "   5. Test manually: curl -X PUT \"https://api.cloudflare.com/client/v4/accounts/\$CF_ACCOUNT_ID/storage/kv/namespaces/\$CF_KV_NAMESPACE_ID/values/\$KEY\" -H \"Authorization: Bearer \$TOKEN\" -d \"test\""
                  return 1
                  ;;
                404)
                  echo "❌ Error: Resource not found"
                  echo "   • Verify that KV namespace exists and is not bound to a worker"
                  return 1
                  ;;
                405)
                  echo "❌ Method not allowed - this suggests API endpoint issue"
                  echo "   • Current endpoint uses PUT method for KV write"
                  echo "   • Verify namespace exists: https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/storage/kv/namespaces/${CF_KV_NAMESPACE_ID}"
                  return 1
                  ;;
              esac
              
              if [ "$attempt" -lt "$max_attempts" ]; then
                local sleep_time=$((base_sleep_time ** attempt))
                echo "   • Waiting ${sleep_time}s before retry..."
                sleep "$sleep_time"
              fi
              
              attempt=$((attempt + 1))
            done
            
            echo "❌ FATAL: Failed to update Cloudflare KV after all retry attempts"
            return 1
          }

          if ! retry_kv_put; then
            echo ""
            echo "❌ FATAL: KV update failed after all retries"
            echo "=> This likely indicates a configuration or authentication problem"
            echo "=> Please verify:"
            echo "   1. CF_API_TOKEN has 'Account.Workers KV Storage:Edit' permission"
            echo "   2. CF_ACCOUNT_ID is correct"
            echo "   3. CF_KV_NAMESPACE_ID exists: wrangler kv:namespace list"
            echo "   4. Network connectivity to Cloudflare API"
            exit 1
          fi

          echo ""
          echo "=> KV successfully updated with IP: ${BESTIP}"
          
          # Perform health check if worker name is provided
          if [ -n "${CF_WORKER_NAME}" ]; then
            echo "=> Performing health check..."
            HEALTH_URL="https://${CF_WORKER_NAME}.workers.dev/health"
            echo "   • Health check URL: ${HEALTH_URL}"
            
            health_check_passed=false
            max_health_checks=3
            
            for health_attempt in $(seq 1 $max_health_checks); do
              echo ""
              echo "→ Health check attempt ${health_attempt}/${max_health_checks}"
              
              http_status=$(curl -s -o /dev/null -w "%{http_code}" \
                --max-time 10 \
                --connect-timeout 5 \
                "${HEALTH_URL}" 2>/dev/null || echo "000")
              
              echo "   • HTTP Status: ${http_status}"
              
              if [ "$http_status" = "200" ]; then
                echo "✅ Health check passed"
                health_check_passed=true
                break
              elif [ "$http_status" = "404" ]; then
                echo "⚠️ Health endpoint not found (might not be implemented)"
                health_check_passed=true
                break
              fi
              
              if [ "$health_attempt" -lt "$max_health_checks" ]; then
                echo "   • Waiting 3s before next attempt..."
                sleep 3
              fi
            done

            if [ "$health_check_passed" = "false" ]; then
              echo "⚠️ WARNING: Health check inconclusive, but KV was updated"
              echo "=> Please verify your Worker manually at: https://${CF_WORKER_NAME}.workers.dev"
            fi
          else
            echo "=> Skipping health check (CF_WORKER_NAME not set)"
          fi
          
          echo ""
          echo "bestip=${BESTIP}" >> "$GITHUB_OUTPUT"
          echo "✅ Update process completed"
          echo "=> End time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "=== Cloudflare KV update ended ==="

  post-cache-artifacts:
    name: Post Cache Rust artifacts & registry
    runs-on: ubuntu-latest
    needs: update-proxy-variable
    if: always()
    steps:
      - name: Post-cache cleanup
        run: echo "Cache maintenance completed"

  post-restore-ip-cache:
    name: Post Restore Best IP Cache
    runs-on: ubuntu-latest
    needs: update-proxy-variable
    if: always()
    steps:
      - name: Post-restore cleanup
        run: echo "IP cache restoration completed"

  cleanup-runs:
    name: Post Checkout repository (full)
    runs-on: ubuntu-latest
    needs: update-proxy-variable
    if: always()
    permissions:
      actions: write
      contents: read
    steps:
      - name: Post job cleanup.
        run: |
          /usr/bin/git version
          git version 2.51.0
          Temporarily overriding HOME='/home/runner/work/_temp/7663695bdc51' before making global git config changes
          Adding repository directory to the temporary git global config as a safe directory
          /usr/bin/git config --global --add safe.directory /home/runner/work/Vip
          /usr/bin/git config --local --name-only --get-regexp core\.sshCommand
          /usr/bin/git submodule foreach --recursive sh -c "git config --local --name-only --get-regexp 'core\.sshCommand' && git config --local --unset-all 'core.sshCommand' || :"
          /usr/bin/git config --local --name-only --get-regexp http\.https\:\/\/github\.com\/\.extraheader
          http.https://github.com/.extraheader
          /usr/bin/git config --local --unset-all http.https://github.com/.extraheader
          /usr/bin/git submodule foreach --recursive sh -c "git config --local --name-only --get-regexp 'http\.https\:\/\/github\.com\/\.extraheader' && git config --local --unset-all 'http.https://github.com/.extraheader' || :"
      
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          retain_days: 0
          keep_minimum_runs: 0

  complete-job:
    name: Complete job
    runs-on: ubuntu-latest
    needs: update-proxy-variable
    if: always()
    steps:
      - name: Job completion summary
        run: |
          echo "=== Workflow Execution Summary ==="
          echo "=> Best IP selected: ${{ needs.update-proxy-variable.outputs.bestip }}"
          echo "=> Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "=> Status: Complete"
