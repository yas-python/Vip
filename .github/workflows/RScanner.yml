name: Rust Proxy Scanner (The Ultimate Final)

# Triggers: manual + hourly schedule
on:
  workflow_dispatch:
  schedule:
    - cron: '0 * * * *' # Run every hour

# Ensure only one scan runs at a time
concurrency:
  group: rust-proxy-scan-final-ultimate
  cancel-in-progress: true

permissions:
  contents: read
  actions: write

env:
  CARGO_TERM_COLOR: always
  CACHE_FILE: .cachelastbestip.txt
  RUST_CACHE_KEY: v4
  CF_ENVIRONMENT: production
  SCAN_BINARY: ./target/release/RScanner
  SCAN_LOG: scan.log
  MAX_CF_RETRIES: "5"
  CF_RETRY_BASE_SLEEP: "2"

jobs:
  update-proxy-variable:
    name: Build → Scan → Update Cloudflare Worker Variable
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      bestip: ${{ steps.scan.outputs.bestip }}

    steps:
      - name: Checkout repository (full)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install system deps (jq, curl, build tools, libssl)
        run: |
          set -euo pipefail
          echo "=> apt-get update..."
          sudo apt-get update -y
          echo "=> installing packages..."
          sudo apt-get install -y jq curl build-essential pkg-config libssl-dev ca-certificates

      - name: Restore Best IP Cache
        uses: actions/cache@v4
        id: ip-cache
        with:
          path: ${{ env.CACHE_FILE }}
          key: rust-proxy-scanner-best-ip-cache-${{ env.RUST_CACHE_KEY }}-${{ runner.os }}

      - name: Install Rust toolchain (stable)
        # FIX: Uses modern action to avoid deprecated 'set-output' warnings.
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
          profile: minimal

      - name: Cache Rust artifacts & registry
        uses: actions/cache@v4
        with:
          path: |
            target
            ~/.cargo/registry
            ~/.cargo/git
          key: rust-cache-${{ env.RUST_CACHE_KEY }}-${{ runner.os }}

      - name: Build Rust project (release)
        run: |
          set -euo pipefail
          if ! cargo build --release 2>&1 | tee build-output.log; then
            echo "❌ cargo build failed."
            exit 1
          fi

      - name: Run scanner and choose best IP
        id: scan
        run: |
          set -euo pipefail
          BIN="${{ env.SCAN_BINARY }}"
          LOG="${{ env.SCAN_LOG }}"
          CACHE_FILE="${{ env.CACHE_FILE }}"
          : > "$LOG"

          # Run scanner and parse log for best IP
          "$BIN" 2>&1 | tee -a "$LOG" || echo "⚠️ Scanner exited with non-zero status; continue to parse log."
          
          # Find best IP (lowest latency)
          awk '
            BEGIN{IGNORECASE=1}
            /PROXY[[:space:]]+LIVE/ {
              if (match($0, /([0-9]+)[[:space:]]*ms/, lat)) { latency=lat[1] } else next
              if (match($0, /([0-9]{1,3}(\.[0-9]{1,3}){3})/ , addr)) { ip=addr[1] } else next
              print latency, ip
            }
          ' "$LOG" | sort -n -k1,1 > candidates.txt || true

          BEST=""
          if [ -s candidates.txt ]; then
            BEST=$(awk 'NR==1{print $2}' candidates.txt)
          fi

          # Fallback: cached file
          if [ -z "${BEST:-}" ] && [ -f "${CACHE_FILE}" ]; then
            CAND=$(tr -d ' \r\n' < ${CACHE_FILE} || true)
            if [[ "$CAND" =~ ^[0-9]{1,3}(\.[0-9]{1,3}){3}$ ]]; then
              BEST="$CAND"
              echo "✅ Using cached IP: $BEST"
            fi
          fi

          if [ -z "${BEST:-}" ]; then
            echo "❌ FATAL: No best IP found from scan or cache."
            exit 1
          fi

          echo "$BEST" > ${CACHE_FILE} || true
          echo "bestip=${BEST}" >> "$GITHUB_OUTPUT"
          echo "✅ Scanner step complete. bestip=${BEST}"

      - name: Update Cloudflare Worker Variable (Script Vars Method) with retries
        env:
          CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
          CF_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
          CF_WORKER_NAME: ${{ secrets.CF_WORKER_NAME }}
          CF_VAR_NAME: ${{ secrets.CF_VAR_NAME }}
          BESTIP: ${{ steps.scan.outputs.bestip }}
          MAX_RETRIES: ${{ env.MAX_CF_RETRIES }}
          BASE_SLEEP: ${{ env.CF_RETRY_BASE_SLEEP }}
        run: |
          set -euo pipefail
          echo "=== Cloudflare update step start ==="

          # Check secrets/outputs
          : "${BESTIP:?BESTIP is required}"
          : "${CF_ACCOUNT_ID:?CF_ACCOUNT_ID is required}"
          : "${CF_API_TOKEN:?CF_API_TOKEN is required}"
          : "${CF_WORKER_NAME:?CF_WORKER_NAME is required}"
          : "${CF_VAR_NAME:?CF_VAR_NAME is required}"
          
          # API URL for PUT/POST Script Variables
          # We use /script/variables instead of /services/environments/settings
          # to bypass the persistent 'workers.services:edit' error.
          API_URL="https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/workers/scripts/${CF_WORKER_NAME}/variables"
          
          echo "DEBUG: Worker Name: ${CF_WORKER_NAME}"
          echo "DEBUG: Variable Name: ${CF_VAR_NAME}"
          echo "DEBUG: Target API URL: ${API_URL}"

          # Helper: retry function
          retry_request() {
            local method="$1"
            local url="$2"
            local data="${3:-}"
            local attempt=1
            local max="${MAX_RETRIES:-5}"
            local log_file="curl_output.log"
            
            while [ "$attempt" -le "$max" ]; do
              echo "→ Attempt #$attempt: ${method} ${url}"
              
              if [ -z "$data" ]; then
                response=$(curl -s -v -w "\n%{http_code}" -X "$method" "$url" -H "Authorization: Bearer ${CF_API_TOKEN}" -H "Content-Type: application/json" 2>&1 | tee "$log_file")
              else
                response=$(curl -s -v -w "\n%{http_code}" -X "$method" "$url" -H "Authorization: Bearer ${CF_API_TOKEN}" -H "Content-Type: application/json" --data "$data" 2>&1 | tee "$log_file")
              fi

              http_code=$(tail -n1 "$log_file" | tail -c 4)
              
              if [[ "$http_code" =~ ^[0-9]{3}$ ]] && [ "$http_code" -ge 200 ] && [ "$http_code" -lt 300 ]; then
                echo "→ HTTP $http_code success."
                local json_body=$(grep -o '{.*}' "$log_file" || true)
                echo "$json_body"
                return 0
              else
                echo "⚠️ HTTP $http_code (attempt $attempt). Request failed."
                echo "❌ Cloudflare API Full Response (for Debugging):"
                cat "$log_file" || true
                
                if [ "$attempt" -lt "$max" ]; then
                  sleep $CF_RETRY_BASE_SLEEP
                fi
              fi
              attempt=$((attempt+1))
            done
            return 1
          }
          
          # 1. DELETE the old variable if it exists (Cloudflare only allows PUT for new vars, or DELETE then PUT/POST for updates)
          # We ignore the error if it doesn't exist
          echo "1. Attempting DELETE old variable (${CF_VAR_NAME}) (error ignored if not found)..."
          retry_request "DELETE" "${API_URL}/${CF_VAR_NAME}" || echo "Continuing..."
          
          # 2. POST the new variable (Plaintext)
          echo "2. Posting new variable/value: ${CF_VAR_NAME} = ${BESTIP}"
          PAYLOAD='{"type":"plain_text", "value":"'"$BESTIP"'", "name":"'"$CF_VAR_NAME"'"}'
          
          if ! post_body=$(retry_request "POST" "${API_URL}" "$PAYLOAD"); then
            echo "❌ Cloudflare POST failed. Final check: ensure CF_ACCOUNT_ID and CF_WORKER_NAME are 100% correct."
            exit 1
          fi

          echo "✅ Cloudflare Worker Variable '${CF_VAR_NAME}' updated successfully."
          echo "=== Cloudflare update step end ==="

  ---

  cleanup-runs:
    name: Cleanup old workflow runs
    runs-on: ubuntu-latest
    needs: update-proxy-variable
    if: always()
    permissions:
      actions: write
    steps:
      - name: Delete old workflow runs (retain 0 days / keep 0)
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          retain_days: 0
          keep_minimum_runs: 0
