name: Rust Proxy Scanner (Ultimate) - KV Update

on:
  workflow_dispatch:
  schedule:
    - cron: '0 * * * *'

concurrency:
  group: rust-proxy-scan-final-plaintext
  cancel-in-progress: true

permissions:
  contents: read
  actions: write

env:
  CARGO_TERM_COLOR: always
  CACHE_FILE: .cachelastbestip.txt
  RUST_CACHE_KEY: v4
  CF_ENVIRONMENT: production
  SCAN_BINARY: ./target/release/RScanner
  SCAN_LOG: scan.log
  MAX_CF_RETRIES: "5"
  CF_RETRY_BASE_SLEEP: "2"
  SCANNER_TIMEOUT: "600"

jobs:
  update-proxy-variable:
    name: Build ‚Üí Scan ‚Üí Update Cloudflare KV (RScanner)
    runs-on: ubuntu-latest
    timeout-minutes: 45
    outputs:
      bestip: ${{ steps.scan.outputs.bestip }}

    steps:
      - name: Checkout repository (full)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install system dependencies
        run: |
          set -euo pipefail
          echo "=> Updating package lists..."
          sudo apt-get update -y
          echo "=> Installing required packages..."
          sudo apt-get install -y jq curl netcat-openbsd build-essential pkg-config libssl-dev ca-certificates coreutils

      - name: Restore Best IP Cache
        uses: actions/cache@v4
        id: ip-cache
        with:
          path: ${{ env.CACHE_FILE }}
          key: rust-proxy-scanner-best-ip-cache-${{ env.RUST_CACHE_KEY }}-${{ runner.os }}
          restore-keys: |
            rust-proxy-scanner-best-ip-cache-${{ env.RUST_CACHE_KEY }}-
            rust-proxy-scanner-best-ip-cache-

      - name: Install Rust toolchain (stable)
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Cache Rust artifacts and registry
        uses: actions/cache@v4
        with:
          path: |
            target
            ~/.cargo/registry
            ~/.cargo/git
          key: rust-cache-${{ env.RUST_CACHE_KEY }}-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            rust-cache-${{ env.RUST_CACHE_KEY }}-${{ runner.os }}-

      - name: Build Rust project (release)
        run: |
          set -euo pipefail
          echo "=> Starting cargo build --release"
          echo "=> Build timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"

          if ! cargo build --release 2>&1 | tee build-output.log; then
            echo "‚ùå Cargo build failed. Showing last 200 lines:"
            tail -n 200 build-output.log || true
            exit 1
          fi

          echo "‚úÖ Cargo build completed successfully"
          ls -lah target/release/ || true

          if [ -f "${{ env.SCAN_BINARY }}" ]; then
            file "${{ env.SCAN_BINARY }}" || true
            echo "‚úÖ Scanner binary verified"
          else
            echo "‚ùå ERROR: Scanner binary not found at ${{ env.SCAN_BINARY }}"
            exit 1
          fi

      - name: Run scanner and select best IP
        id: scan
        timeout-minutes: 15
        run: |
          set -euo pipefail
          echo "=== Scanner execution started ==="
          echo "=> Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"

          BIN="${{ env.SCAN_BINARY }}"
          LOG="${{ env.SCAN_LOG }}"
          CACHE_FILE="${{ env.CACHE_FILE }}"
          TIMEOUT="${{ env.SCANNER_TIMEOUT }}"

          : > "$LOG"

          if [ ! -f "$BIN" ]; then
            echo "‚ùå FATAL: Scanner binary not found at $BIN"
            ls -la target/release/ || true
            exit 1
          fi

          chmod +x "$BIN"

          echo "üöÄ Executing scanner (timeout: ${TIMEOUT}s)"

          set +e
          timeout "${TIMEOUT}s" "$BIN" > "$LOG" 2>&1
          SCANNER_EXIT_CODE=$?
          set -e

          if [ $SCANNER_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ Scanner completed successfully"
          elif [ $SCANNER_EXIT_CODE -eq 124 ]; then
            echo "‚ö†Ô∏è Scanner timed out after ${TIMEOUT}s"
            echo "=> Attempting to parse available results..."
          else
            echo "‚ö†Ô∏è Scanner exited with code $SCANNER_EXIT_CODE"
            echo "=> Attempting to parse available results..."
          fi

          echo "=> Scanner finished at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          LOG_LINES=$(wc -l < "$LOG" 2>/dev/null || echo 0)
          echo "=> Log contains ${LOG_LINES} lines"

          echo "üîç Parsing results for live proxies..."

          grep -iE "(PROXY[[:space:]]+LIVE|selected.*IP|best.*IP)" "$LOG" | \
            grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}[[:space:]]*\([0-9]+[[:space:]]*m?s\)' | \
            sed -E 's/^[[:space:]]*([0-9.]+)[[:space:]]*\(([0-9]+)[[:space:]]*m?s\)/\2 \1/' | \
            awk '{
              split($2, octets, ".")
              if (length(octets) == 4) {
                valid = 1
                for (i = 1; i <= 4; i++) {
                  if (octets[i] !~ /^[0-9]+$/ || octets[i] < 0 || octets[i] > 255) {
                    valid = 0
                    break
                  }
                }
                if (valid && $1 ~ /^[0-9]+$/ && $1 > 0) {
                  print $1, $2
                }
              }
            }' > unsorted_candidates.txt || touch unsorted_candidates.txt

          if [ -s unsorted_candidates.txt ]; then
            sort -n -k1,1 unsorted_candidates.txt | head -n 20 > candidates.txt 2>/dev/null || {
              echo "‚ö†Ô∏è Sort command failed, using unsorted data"
              head -n 20 unsorted_candidates.txt > candidates.txt
            }
          else
            touch candidates.txt
          fi

          CANDIDATES_COUNT=$(wc -l < candidates.txt 2>/dev/null || echo 0)
          echo "=> Found ${CANDIDATES_COUNT} valid candidate IPs"

          if [ "$CANDIDATES_COUNT" -gt 0 ]; then
            echo "=> Top 5 candidates (sorted by lowest latency):"
            head -n 5 candidates.txt | while read -r latency ip; do
              echo "   ‚Ä¢ $ip ‚Üí ${latency}ms latency"
            done
          fi

          BEST_IP=""
          BEST_LATENCY=""

          if [ -s candidates.txt ]; then
            read -r BEST_LATENCY BEST_IP < candidates.txt
            echo "üéØ Best IP selected (lowest ping): $BEST_IP with ${BEST_LATENCY}ms latency"
          else
            echo "üü° No live proxies found in current scan results"
          fi

          if [ -z "${BEST_IP}" ] && [ -f "${CACHE_FILE}" ]; then
            echo "üîÅ Attempting to use cached IP as fallback..."
            CACHED_IP=$(tr -d ' \r\n\t' < "${CACHE_FILE}" 2>/dev/null || true)

            if [[ "$CACHED_IP" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
              IFS='.' read -ra OCTETS <<< "$CACHED_IP"
              VALID=true
              for octet in "${OCTETS[@]}"; do
                if [ "$octet" -lt 0 ] || [ "$octet" -gt 255 ]; then
                  VALID=false
                  break
                fi
              done

              if [ "$VALID" = true ]; then
                BEST_IP="$CACHED_IP"
                echo "‚úÖ Using cached IP: $BEST_IP"
              else
                echo "‚ö†Ô∏è Cached IP has invalid octets: ${CACHED_IP}"
              fi
            else
              echo "‚ö†Ô∏è Cache contains invalid IP format: ${CACHED_IP}"
            fi
          fi

          if [ -z "${BEST_IP}" ]; then
            echo "‚ùå FATAL: No valid IP available from scan or cache"
            echo "=> Scan log preview (last 150 lines):"
            tail -n 150 "$LOG" || true
            exit 1
          fi

          if ! [[ "$BEST_IP" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
            echo "‚ùå FATAL: Invalid IP format: $BEST_IP"
            exit 1
          fi

          IFS='.' read -ra FINAL_OCTETS <<< "$BEST_IP"
          for octet in "${FINAL_OCTETS[@]}"; do
            if [ "$octet" -lt 0 ] || [ "$octet" -gt 255 ]; then
              echo "‚ùå FATAL: IP octet out of range: $BEST_IP"
              exit 1
            fi
          done

          echo "üíæ Saving best IP to cache"
          echo -n "$BEST_IP" > "${CACHE_FILE}"

          CACHE_VERIFICATION=$(cat "${CACHE_FILE}" 2>/dev/null || echo "")
          echo "=> Cache verified: $CACHE_VERIFICATION"

          echo "bestip=${BEST_IP}" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Scanner step completed successfully"
          echo "=> Selected IP: ${BEST_IP}"
          [ -n "${BEST_LATENCY}" ] && echo "=> Latency: ${BEST_LATENCY}ms (lowest ping)"
          echo "=== Scanner execution ended ==="

      - name: Upload scan.log for debugging (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: scan-log-${{ github.run_id }}
          path: ${{ env.SCAN_LOG }}
          retention-days: 7
          if-no-files-found: warn

      - name: Upload candidates file for debugging
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: candidates-${{ github.run_id }}
          path: candidates.txt
          retention-days: 7
          if-no-files-found: ignore

      - name: Update Cloudflare KV (REST API) with retries + wrangler fallback + health-check
        id: update-kv
        env:
          CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
          CF_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
          CF_KV_NAMESPACE_ID: ${{ secrets.CF_KV_NAMESPACE_ID }}
          CF_WORKER_NAME: ${{ secrets.CF_WORKER_NAME }}
          CF_VAR_KEY: ${{ secrets.CF_VAR_KEY }}
          BESTIP: ${{ steps.scan.outputs.bestip }}
          MAX_RETRIES: ${{ env.MAX_CF_RETRIES }}
          BASE_SLEEP: ${{ env.CF_RETRY_BASE_SLEEP }}
          # Optional: binding name used in worker; set as secret CF_KV_BINDING_NAME, default "KV"
          CF_KV_BINDING_NAME: ${{ secrets.CF_KV_BINDING_NAME || 'KV' }}
        run: |
          set -euo pipefail

          echo "=== Cloudflare KV update started ==="
          echo "=> Start time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "=> Configuration:"
          echo "   ‚Ä¢ KV Namespace ID: ${CF_KV_NAMESPACE_ID}"
          echo "   ‚Ä¢ KV Key: ${CF_VAR_KEY}"
          echo "   ‚Ä¢ Best IP: ${BESTIP}"
          echo "   ‚Ä¢ Worker: ${CF_WORKER_NAME}"
          echo "   ‚Ä¢ KV binding name (for wrangler fallback): ${CF_KV_BINDING_NAME}"

          for required_var in CF_ACCOUNT_ID CF_API_TOKEN CF_KV_NAMESPACE_ID CF_VAR_KEY BESTIP; do
            if [ -z "${!required_var}" ]; then
              echo "‚ùå ERROR: ${required_var} is not set"
              exit 1
            fi
          done

          echo "=> All required environment variables validated"

          # retry function for REST PUT
          retry_kv_put() {
            local attempt=1
            local max_attempts="${MAX_RETRIES:-5}"
            local base_sleep_time="${BASE_SLEEP:-2}"

            while [ "$attempt" -le "$max_attempts" ]; do
              echo ""
              echo "‚Üí Attempt #${attempt}/${max_attempts} to PUT KV value (REST API)"

              local api_url="https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/storage/kv/namespaces/${CF_KV_NAMESPACE_ID}/values/${CF_VAR_KEY}"
              echo "   URL: ${api_url}"

              local temp_response
              temp_response=$(mktemp)

              local http_code
              http_code=$(curl -s -w "%{http_code}" -X PUT "${api_url}" \
                -H "Authorization: Bearer ${CF_API_TOKEN}" \
                -H "Content-Type: text/plain" \
                --data-raw "${BESTIP}" \
                --max-time 15 \
                --connect-timeout 10 \
                --retry 0 \
                -o "$temp_response" 2>&1 || echo "000")

              local response_body
              response_body=$(cat "$temp_response" 2>/dev/null || echo "")
              rm -f "$temp_response"

              echo "   ‚Ä¢ HTTP Status: ${http_code}"

              if [ "$http_code" = "200" ] || [ "$http_code" = "204" ]; then
                echo "‚úÖ Cloudflare KV updated successfully (REST): ${BESTIP}"
                if [ -n "$response_body" ] && [ "$response_body" != "null" ]; then
                  echo "   ‚Ä¢ Response: $(echo "$response_body" | head -c 200)"
                fi
                return 0
              fi

              echo "‚ö†Ô∏è KV PUT failed (HTTP ${http_code})"
              if [ -n "$response_body" ]; then
                echo "   ‚Ä¢ Response body (first 500 chars):"
                echo "${response_body}" | head -c 500
                echo ""
              fi

              case "$http_code" in
                000)
                  echo "   ‚Ä¢ Network error or timeout occurred"
                  ;;
                401)
                  echo "‚ùå FATAL: Unauthorized - CF_API_TOKEN invalid"
                  return 2
                  ;;
                403)
                  echo "‚ùå FATAL: Forbidden - insufficient permissions or namespace bound to Worker"
                  # 403 could be permissions OR binding; treat as fatal for REST (let fallback handle binding)
                  return 3
                  ;;
                404)
                  echo "‚ùå FATAL: Not Found - resource does not exist"
                  return 4
                  ;;
                405)
                  echo "‚ùå REST returned 405 - Method Not Allowed (namespace likely bound to a Worker). Will trigger wrangler fallback."
                  return 5
                  ;;
                429)
                  echo "   ‚Ä¢ Rate limited - will retry with backoff"
                  ;;
                500|502|503|504)
                  echo "   ‚Ä¢ Cloudflare server error - transient, will retry"
                  ;;
                *)
                  echo "   ‚Ä¢ Unexpected HTTP code: ${http_code} - will retry"
                  ;;
              esac

              if [ "$attempt" -lt "$max_attempts" ]; then
                local sleep_duration=$((base_sleep_time * attempt))
                echo "   ‚Ä¢ Waiting ${sleep_duration}s before retry..."
                sleep "$sleep_duration"
              fi

              attempt=$((attempt + 1))
            done

            echo ""
            echo "‚ùå All REST retry attempts exhausted"
            return 1
          }

          # run REST attempt first
          retry_kv_put
          rv=$?

          if [ "$rv" -eq 0 ]; then
            echo "‚úÖ KV successfully updated via REST API: ${BESTIP}"
          elif [ "$rv" -eq 5 ] || [ "$rv" -eq 3 ] || [ "$rv" -eq 1 ]; then
            # 5 -> 405 (namespace bound to worker), 3 -> 403 (maybe bound or permissions), 1 -> retries exhausted
            echo ""
            echo "‚Üí Attempting wrangler CLI fallback to write KV via Worker binding..."
            echo "   (This writes using the Worker binding and does not require unbinding the namespace.)"

            # Install node & npm & wrangler minimally (if not present)
            echo "=> Installing nodejs & npm (if missing)"
            if ! command -v node >/dev/null 2>&1; then
              sudo apt-get update -y
              sudo apt-get install -y nodejs npm || true
            fi

            # Install wrangler (v2 recommended)
            echo "=> Installing wrangler (npm install -g wrangler)"
            npm install -g wrangler@2 --no-progress || {
              echo "‚ö†Ô∏è npm install -g wrangler failed, attempting npx fallback..."
            }

            if ! command -v wrangler >/dev/null 2>&1; then
              # try npx fallback invocation wrapper
              echo "‚ö†Ô∏è wrangler not found after install; will try npx wrangler"
              WRANGLER_CMD="npx wrangler"
            else
              WRANGLER_CMD="wrangler"
            fi

            echo "=> Using wrangler command: ${WRANGLER_CMD}"

            # Ensure CF_API_TOKEN is available to wrangler command
            export CF_API_TOKEN="${CF_API_TOKEN}"
            export CLOUDFLARE_API_TOKEN="${CF_API_TOKEN}"

            # Binding name (from secret or default)
            BINDING_NAME="${CF_KV_BINDING_NAME:-KV}"
            echo "=> Binding name: ${BINDING_NAME}"

            echo "‚Üí Executing: ${WRANGLER_CMD} kv:key put --binding=${BINDING_NAME} ${CF_VAR_KEY} ${BESTIP} --account-id ${CF_ACCOUNT_ID}"
            set +e
            ${WRANGLER_CMD} kv:key put --binding="${BINDING_NAME}" "${CF_VAR_KEY}" "${BESTIP}" --account-id "${CF_ACCOUNT_ID}" 2>&1 | tee /tmp/wrangler_put.log
            WRANGLER_EXIT=$?
            set -e

            if [ "$WRANGLER_EXIT" -eq 0 ]; then
              echo "‚úÖ KV successfully updated via wrangler fallback: ${BESTIP}"
            else
              echo "‚ùå FATAL: wrangler fallback failed (exit ${WRANGLER_EXIT}). See /tmp/wrangler_put.log"
              tail -n 200 /tmp/wrangler_put.log || true
              exit 1
            fi

          else
            echo "‚ùå FATAL: REST KV update failed fatally (code $rv). Not attempting fallback."
            exit 1
          fi

          # After successful KV update, perform health-check if worker present
          if [ -n "${CF_WORKER_NAME}" ]; then
            echo ""
            echo "=> Performing Worker health check..."
            HEALTH_URL="https://${CF_WORKER_NAME}.workers.dev/health"
            echo "   ‚Ä¢ Health check URL: ${HEALTH_URL}"

            health_check_passed=false
            max_health_checks=3

            for health_attempt in $(seq 1 $max_health_checks); do
              echo ""
              echo "‚Üí Health check attempt ${health_attempt}/${max_health_checks}"

              http_status=$(curl -s -o /dev/null -w "%{http_code}" \
                --max-time 10 \
                --connect-timeout 5 \
                "${HEALTH_URL}" 2>/dev/null || echo "000")

              echo "   ‚Ä¢ HTTP Status: ${http_status}"

              if [ "$http_status" = "200" ]; then
                echo "‚úÖ Health check passed - Worker is responding correctly"
                health_check_passed=true
                break
              elif [ "$http_status" = "404" ]; then
                echo "‚ÑπÔ∏è Health endpoint not found (normal if not implemented)"
                health_check_passed=true
                break
              elif [ "$http_status" = "000" ]; then
                echo "‚ö†Ô∏è Could not connect to Worker"
              else
                echo "‚ö†Ô∏è Unexpected status code: ${http_status}"
              fi

              if [ "$health_attempt" -lt "$max_health_checks" ]; then
                echo "   ‚Ä¢ Waiting 3s before next attempt..."
                sleep 3
              fi
            done

            if [ "$health_check_passed" = "false" ]; then
              echo ""
              echo "‚ö†Ô∏è WARNING: Health check failed, but KV was updated to: ${BESTIP}"
              echo "=> Please verify your Worker deployment manually"
              echo "=> Visit: https://${CF_WORKER_NAME}.workers.dev"
            fi
          else
            echo "=> Skipping health check (CF_WORKER_NAME not configured)"
          fi

          echo ""
          echo "bestip=${BESTIP}" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Cloudflare KV update completed successfully"
          echo "=> Final IP: ${BESTIP}"
          echo "=> End time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "=== Cloudflare KV update ended ==="

  post-cache-artifacts:
    name: Post Cache Rust artifacts & registry
    runs-on: ubuntu-latest
    needs: update-proxy-variable
    if: always()
    steps:
      - name: Cache maintenance completed
        run: |
          echo "Post job cleanup completed."
          echo "Rust artifacts and registry cache preserved for future runs"

  post-restore-ip-cache:
    name: Post Restore Best IP Cache
    runs-on: ubuntu-latest
    needs: update-proxy-variable
    if: always()
    steps:
      - name: IP cache status
        run: |
          echo "Post job cleanup completed."
          echo "Best IP cache has been updated for subsequent workflow runs"

  cleanup-runs:
    name: Post Checkout repository (full)
    runs-on: ubuntu-latest
    needs: update-proxy-variable
    if: always()
    permissions:
      actions: write
      contents: read
    steps:
      - name: Checkout for cleanup
        uses: actions/checkout@v4

      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          retain_days: 0
          keep_minimum_runs: 0

  complete-job:
    name: Complete job
    runs-on: ubuntu-latest
    needs: update-proxy-variable
    if: always()
    steps:
      - name: Workflow execution summary
        run: |
          echo "=== Workflow Execution Summary ==="
          echo "=> Best IP selected (lowest latency): ${{ needs.update-proxy-variable.outputs.bestip }}"
          echo "=> Execution completed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "=> Status: Complete"
          echo "=> All steps executed successfully"
