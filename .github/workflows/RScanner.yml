Name: Rust Proxy Scanner (Ultimate) - KV Update

on:
  workflow_dispatch:
  schedule:
    - cron: '0 * * * *'

concurrency:
  group: rust-proxy-scan-final-plaintext
  cancel-in-progress: true

permissions:
  contents: read
  actions: write

env:
  CARGO_TERM_COLOR: always
  CACHE_FILE: .cachelastbestip.txt
  RUST_CACHE_KEY: v4
  CF_ENVIRONMENT: production
  SCAN_BINARY: ./target/release/RScanner
  SCAN_LOG: scan.log
  MAX_CF_RETRIES: "5"
  CF_RETRY_BASE_SLEEP: "2"
  SCANNER_TIMEOUT: "600"
  
jobs:
  update-proxy-variable:
    name: Build â†’ Scan â†’ Update Cloudflare KV (RScanner)
    runs-on: ubuntu-latest
    timeout-minutes: 45
    outputs:
      bestip: ${{ steps.scan.outputs.bestip }}

    steps:
      - name: Checkout repository (full)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install system dependencies
        run: |
          set -euo pipefail
          echo "=> Updating package lists..."
          sudo apt-get update -y
          echo "=> Installing required packages..."
          sudo apt-get install -y jq curl netcat-openbsd build-essential pkg-config libssl-dev ca-certificates coreutils

      - name: Restore Best IP Cache
        uses: actions/cache@v4
        id: ip-cache
        with:
          path: ${{ env.CACHE_FILE }}
          key: rust-proxy-scanner-best-ip-cache-${{ env.RUST_CACHE_KEY }}-${{ runner.os }}
          restore-keys: |
            rust-proxy-scanner-best-ip-cache-${{ env.RUST_CACHE_KEY }}-
            rust-proxy-scanner-best-ip-cache-

      - name: Install Rust toolchain (stable)
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Cache Rust artifacts and registry
        uses: actions/cache@v4
        with:
          path: |
            target
            ~/.cargo/registry
            ~/.cargo/git
          key: rust-cache-${{ env.RUST_CACHE_KEY }}-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            rust-cache-${{ env.RUST_CACHE_KEY }}-${{ runner.os }}-

      - name: Build Rust project (release)
        run: |
          set -euo pipefail
          echo "=> Starting cargo build --release"
          echo "=> Build timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
                
          if ! cargo build --release 2>&1 | tee build-output.log; then
            echo "âŒ Cargo build failed. Showing last 200 lines:"
            tail -n 200 build-output.log || true
            exit 1
          fi
                
          echo "âœ… Cargo build completed successfully"
          ls -lah target/release/ || true
                
          if [ -f "${{ env.SCAN_BINARY }}" ]; then
            file "${{ env.SCAN_BINARY }}" || true
            echo "âœ… Scanner binary verified"
          else
            echo "âŒ ERROR: Scanner binary not found at ${{ env.SCAN_BINARY }}"
            exit 1
          fi

      - name: Run scanner and select best IP (Lowest Ping)
        id: scan
        timeout-minutes: 15
        run: |
          set -euo pipefail
          echo "=== Scanner execution started ==="
          echo "=> Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
                
          BIN="${{ env.SCAN_BINARY }}"
          LOG="${{ env.SCAN_LOG }}"
          CACHE_FILE="${{ env.CACHE_FILE }}"
          TIMEOUT="${{ env.SCANNER_TIMEOUT }}"
                
          : > "$LOG" # Initialize empty log file
      
          if [ ! -f "$BIN" ]; then
            echo "âŒ FATAL: Scanner binary not found at $BIN"
            ls -la target/release/ || true
            exit 1
          fi
      
          chmod +x "$BIN"
                
          echo "ðŸš€ Executing scanner (timeout: ${TIMEOUT}s)"
                
          # Run scanner and capture output
          set +e
          timeout "${TIMEOUT}s" "$BIN" > "$LOG" 2>&1
          SCANNER_EXIT_CODE=$?
          set -e
                
          if [ $SCANNER_EXIT_CODE -eq 0 ]; then
            echo "âœ… Scanner completed successfully"
          elif [ $SCANNER_EXIT_CODE -eq 124 ]; then
            echo "âš ï¸ Scanner timed out after ${TIMEOUT}s"
            echo "=> Attempting to parse available results..."
          else
            echo "âš ï¸ Scanner exited with code $SCANNER_EXIT_CODE"
            echo "=> Attempting to parse available results..."
          fi
      
          echo "=> Scanner finished at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          LOG_LINES=$(wc -l < "$LOG" 2>/dev/null || echo 0)
          echo "=> Log contains ${LOG_LINES} lines"
      
          echo "ðŸ” Parsing results for live proxies..."
                
          # Extracts IP and Latency, then reformats to "Latency IP"
          grep -iE "(PROXY[[:space:]]+LIVE)" "$LOG" | \
            grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}[[:space:]]*\([0-9]+[[:space:]]*m?s\)' | \
            sed -E 's/^[[:space:]]*([0-9.]+)[[:space:]]*\(([0-9]+)[[:space:]]*m?s\)/\2 \1/' | \
            awk '{
              # Basic IP validation
              split($2, octets, ".")
              if (length(octets) == 4 && $1 ~ /^[0-9]+$/ && $1 > 0) {
                print $1, $2
              }
            }' > unsorted_candidates.txt || touch unsorted_candidates.txt
                
          # Sort by latency numerically (lowest ping first) and take top 20
          if [ -s unsorted_candidates.txt ]; then
            sort -n -k1,1 unsorted_candidates.txt | head -n 20 > candidates.txt 2>/dev/null || {
              echo "âš ï¸ Sort command failed, using unsorted data"
              head -n 20 unsorted_candidates.txt > candidates.txt
            }
          else
            touch candidates.txt
          fi
      
          CANDIDATES_COUNT=$(wc -l < candidates.txt 2>/dev/null || echo 0)
          echo "=> Found ${CANDIDATES_COUNT} valid candidate IPs"
                
          if [ "$CANDIDATES_COUNT" -gt 0 ]; then
            echo "=> Top 5 candidates (sorted by lowest latency):"
            head -n 5 candidates.txt | while read -r latency ip; do
              echo "   â€¢ $ip â†’ ${latency}ms latency"
            done
          fi
      
          BEST_IP=""
          BEST_LATENCY=""
      
          # Select the IP with the LOWEST latency (first line after numerical sort)
          if [ -s candidates.txt ]; then
            read -r BEST_LATENCY BEST_IP < candidates.txt
            echo "ðŸŽ¯ Best IP selected (lowest ping): $BEST_IP with ${BEST_LATENCY}ms latency"
          else
            echo "ðŸŸ¡ No live proxies found in current scan results"
          fi
      
          # Fallback to cached IP if no new IP found
          if [ -z "${BEST_IP}" ] && [ -f "${CACHE_FILE}" ]; then
            echo "ðŸ” Attempting to use cached IP as fallback..."
            CACHED_IP=$(tr -d ' \r\n\t' < "${CACHE_FILE}" 2>/dev/null || true)
                  
            if [[ "$CACHED_IP" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
              # Validate each octet is 0-255
              IFS='.' read -ra OCTETS <<< "$CACHED_IP"
              VALID=true
              for octet in "${OCTETS[@]}"; do
                if [ "$octet" -lt 0 ] || [ "$octet" -gt 255 ]; then
                  VALID=false
                  break
                fi
              done
              
              if [ "$VALID" = true ]; then
                BEST_IP="$CACHED_IP"
                echo "âœ… Using cached IP: $BEST_IP"
              else
                echo "âš ï¸ Cached IP has invalid octets: ${CACHED_IP}"
              fi
            else
              echo "âš ï¸ Cache contains invalid IP format: ${CACHED_IP}"
            fi
          fi
      
          # Final validation
          if [ -z "${BEST_IP}" ]; then
            echo "âŒ FATAL: No valid IP available from scan or cache"
            tail -n 150 "$LOG" || true
            exit 1
          fi
      
          # Save to cache for future runs
          echo "ðŸ’¾ Saving best IP to cache"
          echo -n "$BEST_IP" > "${CACHE_FILE}"
      
          # Set output for next steps
          echo "bestip=${BEST_IP}" >> "$GITHUB_OUTPUT"
          echo "âœ… Scanner step completed successfully"

      - name: Upload scan.log for debugging (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: scan-log-${{ github.run_id }}
          path: ${{ env.SCAN_LOG }}
          retention-days: 7
          if-no-files-found: warn

      - name: Upload candidates file for debugging
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: candidates-${{ github.run_id }}
          path: candidates.txt
          retention-days: 7
          if-no-files-found: ignore
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20' # Use a current LTS version

      - name: Install Wrangler CLI
        run: |
          set -euo pipefail
          echo "=> Installing Wrangler CLI using npm..."
          npm install -g wrangler
          echo "=> Wrangler version check:"
          wrangler --version
      
      # ðŸ’¡ ØªØºÛŒÛŒØ± ØªØ®ØµØµÛŒ: Ù…Ø±Ø­Ù„Ù‡ Ø§ÙˆÙ„ - Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒÙ„ Ù…Ø­ØªÙˆØ§ÛŒ KV
      - name: Create KV content file
        id: create_kv_file
        run: |
          set -euo pipefail
          IP_FILE="best_ip_value.txt"
          echo -n "${{ steps.scan.outputs.bestip }}" > $IP_FILE
          echo "KV_FILE=$IP_FILE" >> "$GITHUB_OUTPUT"
          echo "âœ… Created file for KV update: $IP_FILE"

      # ðŸ’¡ ØªØºÛŒÛŒØ± ØªØ®ØµØµÛŒ: Ù…Ø±Ø­Ù„Ù‡ Ø¯ÙˆÙ… - Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Cloudflare KV Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù…Ø³ÛŒØ± ÙØ§ÛŒÙ„
      - name: Update Cloudflare KV using Wrangler (via File Path)
        id: update-kv
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_API_TOKEN }} 
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
          CF_KV_NAMESPACE_ID: ${{ secrets.CF_KV_NAMESPACE_ID }}
          CF_WORKER_NAME: ${{ secrets.CF_WORKER_NAME }}
          CF_VAR_KEY: ${{ secrets.CF_VAR_KEY }}
          BESTIP: ${{ steps.scan.outputs.bestip }}
          KV_FILE: ${{ steps.create_kv_file.outputs.KV_FILE }} # Ù…Ø³ÛŒØ± ÙØ§ÛŒÙ„
        run: |
          set -euo pipefail
          
          echo "=== Cloudflare KV update (Wrangler) started ==="
          
          for required_var in CLOUDFLARE_API_TOKEN CLOUDFLARE_ACCOUNT_ID CF_KV_NAMESPACE_ID CF_VAR_KEY BESTIP; do
            if [ -z "${!required_var}" ]; then
              echo "âŒ ERROR: ${required_var} is not set. Check GitHub Secrets."
              exit 1
            fi
          done
          
          echo "ðŸš€ Attempting to update KV value: ${BESTIP} using file path: ${KV_FILE}"
          
          set +e
          
          # Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¢Ø±Ú¯ÙˆÙ…Ø§Ù† --path Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„ Ø¨Ù‡ Ø¬Ø§ÛŒ Ø±Ø´ØªÙ‡ Ù…Ø³ØªÙ‚ÛŒÙ…
          wrangler kv key put \
            "${CF_VAR_KEY}" \
            --path "${KV_FILE}" \
            --namespace-id "${CF_KV_NAMESPACE_ID}"
          
          WRANGLER_EXIT_CODE=$?
          set -e
          
          if [ $WRANGLER_EXIT_CODE -ne 0 ]; then
            echo "âŒ FATAL: Wrangler command failed with exit code $WRANGLER_EXIT_CODE"
            exit 1
          fi
          
          echo "âœ… KV successfully updated with IP: ${BESTIP}"
          echo "update_status=success" >> "$GITHUB_OUTPUT"
          
      # ðŸ’¡ Ù…Ø±Ø­Ù„Ù‡ Ø¬Ø¯ÛŒØ¯ Ùˆ Ù‡ÙˆØ´Ù…Ù†Ø¯: ØªØ£ÛŒÛŒØ¯ (Readback) Ù…Ù‚Ø¯Ø§Ø± Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯Ù‡ Ø¯Ø± KV
      - name: Verify KV Value Readback
        id: verify_kv
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_API_TOKEN }} 
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
          CF_KV_NAMESPACE_ID: ${{ secrets.CF_KV_NAMESPACE_ID }}
          CF_VAR_KEY: ${{ secrets.CF_VAR_KEY }}
          EXPECTED_IP: ${{ steps.scan.outputs.bestip }}
        run: |
          set -euo pipefail
          
          echo "=== Cloudflare KV Readback Verification ==="
          
          # Ø®ÙˆØ§Ù†Ø¯Ù† Ù…Ù‚Ø¯Ø§Ø± Ø§Ø² Cloudflare KV
          ACTUAL_IP=$(wrangler kv key get "${CF_VAR_KEY}" --namespace-id "${CF_KV_NAMESPACE_ID}" 2>/dev/null || echo "ReadError")
          
          echo "=> Expected IP (From Scan): ${EXPECTED_IP}"
          echo "=> Actual IP (From KV):     ${ACTUAL_IP}"
          
          if [ "$ACTUAL_IP" = "$EXPECTED_IP" ]; then
            echo "âœ… VERIFICATION SUCCESS: IP in KV matches the scanned best IP."
            echo "verification_status=success" >> "$GITHUB_OUTPUT"
          else
            echo "âŒ VERIFICATION FAILED: IP mismatch or ReadError."
            echo "verification_status=failed" >> "$GITHUB_OUTPUT"
            # Ø¯Ø± ØµÙˆØ±Øª Ø¹Ø¯Ù… ØªØ·Ø§Ø¨Ù‚ØŒ ÙØ±Ø¢ÛŒÙ†Ø¯ Ø±Ø§ Ù…ØªÙˆÙ‚Ù Ù†Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ… ØªØ§ Ù…Ø±Ø§Ø­Ù„ Ù†Ù‡Ø§ÛŒÛŒ Ø§Ø¬Ø±Ø§ Ø´ÙˆÙ†Ø¯ØŒ Ø§Ù…Ø§ ÛŒÚ© Ù‡Ø´Ø¯Ø§Ø± Ø´Ø¯ÛŒØ¯ ØµØ§Ø¯Ø± Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ….
          fi

      - name: Worker Health Check & Final Summary
        run: |
          set -euo pipefail
          
          # Ø§Ø¬Ø±Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Health Check Ú©Ù‡ Ù‚Ø¨Ù„Ø§Ù‹ Ø¨ÙˆØ¯ (Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ±)
          if [ -n "${{ secrets.CF_WORKER_NAME }}" ]; then
            echo "=> Performing Worker health check..."
            HEALTH_URL="https://${{ secrets.CF_WORKER_NAME }}.workers.dev/health"
            
            health_check_passed=false
            max_health_checks=3
                  
            for health_attempt in $(seq 1 $max_health_checks); do
              http_status=$(curl -s -o /dev/null -w "%{http_code}" \
                --max-time 10 \
                --connect-timeout 5 \
                "${HEALTH_URL}" 2>/dev/null || echo "000")
                    
              if [ "$http_status" = "200" ]; then
                health_check_passed=true
                break
              fi
              if [ "$health_attempt" -lt "$max_health_checks" ]; then
                sleep 3
              fi
            done
      
            if [ "$health_check_passed" = "false" ]; then
              echo "âš ï¸ WARNING: Health check failed, but KV was updated to: ${{ steps.scan.outputs.bestip }}"
            fi
          else
            echo "=> Skipping health check (CF_WORKER_NAME not configured)"
          fi
          
          # Ø®Ù„Ø§ØµÙ‡â€ŒØ§ÛŒ Ø§Ø² ÙˆØ¶Ø¹ÛŒØª KV
          if [ "${{ steps.verify_kv.outputs.verification_status }}" != "success" ]; then
              echo "ðŸš¨ FATAL WARNING: KV update verification failed. Check Cloudflare Secrets and permissions."
              # Ø¯Ø± Ø§ÛŒÙ†Ø¬Ø§ ØªØµÙ…ÛŒÙ… Ù…ÛŒâ€ŒÚ¯ÛŒØ±ÛŒÙ… Ú©Ù‡ Ø§Ú¯Ø± ØªØ£ÛŒÛŒØ¯ Ø´Ú©Ø³Øª Ø®ÙˆØ±Ø¯ØŒ Ú©Ù„ Workflow Ø±Ø§ Fail Ú©Ù†ÛŒÙ… ØªØ§ Ù…Ø´Ú©Ù„ Ø±Ø§ Ù¾ÛŒØ¯Ø§ Ú©Ù†ÛŒØ¯
              exit 1 
          fi
          
          echo "bestip=${{ steps.scan.outputs.bestip }}" >> "$GITHUB_OUTPUT"
          echo "âœ… Cloudflare KV update completed successfully"
          echo "=== Cloudflare KV update (Wrangler) ended ==="

  post-cache-artifacts:
    name: Post Cache Rust artifacts & registry
    runs-on: ubuntu-latest
    needs: update-proxy-variable
    if: always()
    steps:
      - name: Cache maintenance completed
        run: echo "Cache maintenance completed."

  post-restore-ip-cache:
    name: Post Restore Best IP Cache
    runs-on: ubuntu-latest
    needs: update-proxy-variable
    if: always()
    steps:
      - name: IP cache status
        run: echo "Best IP cache has been updated for subsequent workflow runs"

  cleanup-runs:
    name: Post Checkout repository (full)
    runs-on: ubuntu-latest
    needs: update-proxy-variable
    if: always()
    permissions:
      actions: write
      contents: read
    steps:
      - name: Checkout for cleanup
        uses: actions/checkout@v4
              
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          retain_days: 0
          keep_minimum_runs: 0

  complete-job:
    name: Complete job
    runs-on: ubuntu-latest
    needs: update-proxy-variable
    if: always()
    steps:
      - name: Workflow execution summary
        run: |
          echo "=== Workflow Execution Summary ==="
          echo "=> Best IP selected: ${{ needs.update-proxy-variable.outputs.bestip }}"
          echo "=> Status: Complete"
          if [ "${{ needs.update-proxy-variable.outputs.bestip }}" != "" ]; then
             echo "âœ… KV Update Verified: ${{ steps.verify_kv.outputs.verification_status }}"
          fi
